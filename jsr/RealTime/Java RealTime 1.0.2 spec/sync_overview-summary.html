<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_06) on Mon Jun 26 19:39:55 EDT 2006 -->
<TITLE>
Overview (Synchronization)
</TITLE>

<META NAME="keywords" CONTENT="Overview">

<LINK REL ="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Overview (Synchronization)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">

<HR>
Synchronization
                This section describes classes that specifically manage synchronization.
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#overview_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Packages</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="javax/realtime/package-summary.html">javax.realtime</A></B></TD>
<TD>&nbsp;</TD>
</TR>
</TABLE>

<P>
&nbsp;<A NAME="overview_description"><!-- --></A>
<P>
<h1>Synchronization</h1>
                <p>This section describes classes that specifically manage synchronization. &nbsp;These classes:</p>
                <ul>
                        <li>Allow the setting of a priority inversion control policy either as the default or for specific objects
                        <li>Allow wait-free communication between schedulable objects (especially instances of <code>NoHeapRealtimeThread</code>) and regular Java threads.
                </ul>
                <p>This specification strengthens the semantics of Java <code>synchronized</code> code by mandating monitor execution eligibility control, commonly referred to as priority inversion control. The <a href="javax/realtime/MonitorControl.html"><code>MonitorControl</code></a> class is defined as the superclass of all such execution eligibility control algorithms. Its subclasses <a href="javax/realtime/PriorityInheritance.html"><code>PriorityInheritance</code></a> (required) and <a href="javax/realtime/PriorityCeilingEmulation.html"><code>PriorityCeilingEmulation</code></a> (optional) avoid unbounded priority inversions, which would be unacceptable in real-time systems.</p>
                <p>The classes in this section establish a framework for priority inversion management that applies to priority-oriented schedulers in general, and a specific set of requirements for the base <a href="javax/realtime/PriorityScheduler.html">priority scheduler</a>.</p>
                <p>The wait-free queue classes provide safe, concurrent access to data shared between instances of <a href="javax/realtime/NoHeapRealtimeThread.html"><code>NoHeapRealtimeThread</code></a> and schedulable objects subject to garbage collection delays.</p>
                <h2>Semantics and Requirements</h2>
                <p>This list establishes the semantics and requirements that are applicable across the classes of this section. Semantics that apply to particular classes, constructors, methods, and fields will be found in the class description and the constructor, method, and field detail sections.</p>
                <ol>
                        <li>Terminology: If an object <code>obj</code> has been assigned (either by default or via an explicit method call) the <code>MonitorControlPolicy</code> <code>mcp</code>, then <code>obj</code> is said to be <dfn>governed by</dfn> <code>mcp</code>.
                        <li>The initial default monitor control policy shall be <code>PriorityInheritance</code>. The default policy can be altered by using the <code>setMonitorControl()</code> method.
                        <li>Notwithstanding the preceding rule, an RTSJ implementation may allow the program to establish a different initial default monitor control policy at JVM startup. The program can query the initial default monitor control policy via the method <code>RealtimeSystem.getInitialMonitorControl</code>.
                        <li>The <code>PriorityCeilingEmulation</code> monitor control policy is optional, since it is not widely supported by current RTOSes.
                        <li>An implementation that provides any additional <code>MonitorControl</code> subclasses must document their effects, particularly with respect to priority inversion control.
                        <li>An object's monitor control policy affects <em>any</em> entity that attempts to lock the object; i.e., regular Java threads as well as schedulable objects. <li>When a thread or schedulable object enters synchronized code, the target object's monitor control policy must be supported by the thread or schedulable object's scheduler; otherwise an <code>IllegalThreadStateException</code> is thrown. An implementation that defines a new <code>MonitorControl</code> subclass must document which (if any) schedulers do not support this policy.
                </ol>
                <h3>Semantics for the Base Priority Scheduler</h3>
                <p>The following list defines the main terms and establishes the general semantics and requirements that apply to threads and schedulable objects managed by the base priority scheduler when they synchronize on objects governed by monitor control policies defined in this section.</p>
                <ol>
                        <li>Each thread or schedulable object has a <dfn>base priority</dfn> and an <dfn>active priority</dfn>. A thread or schedulable object that holds a lock on a PCE-governed object also has a <em>ceiling priority.</em><li>The <em>base priority</em> for a thread or schedulable object <code>t</code> is initially the priority that<code> t</code> has when it is created. The base priority is updated (immediately) as an effect of invoking any of the following methods:
                                <ul>
                                        <li><code>pparams.setPriority(prio)</code><br>
                                                if <code>t</code> is a schedulable object with <code>pparams</code> as its <a href="javax/realtime/SchedulingParameters.html"><code>SchedulingParameters,</code></a> where <code>pparams</code> is an instance of <a href="javax/realtime/PriorityParameters.html"><code>PriorityParameters</code></a>; the new base priority is <code>prio</code>
                                        <li><code>t.setSchedulingParameters(pparams)</code><br>
                                                if<code> t</code> is a schedulable object and <code>pparams</code> is an instance of <a href="javax/realtime/PriorityParameters.html"><code>PriorityParameters</code></a>; the new base priority is <code>pparams.getPriority() </code>
                                        <li><code>t.setPriority(prio)</code><br>
                                                if <code>t</code> is a schedulable object, the new base priority is <code>prio</code>.  If it is a Java thread, the new base priority is the lesser of <code>prio</code>,  and the maximum priority for<code> t</code>'s thread group.</ul>
                        <li>When <code>t</code> does not hold any locks, its active priority is the same as its base priority. In such a situation modification of the priority of <code>t</code> through an invocation of any of the above priority-setting methods for<code> t</code> causes <code>t</code> to be placed at the tail of its relevant queue (ready, blocked on a particular object, etc.) at its new priority.<font color="#00FF00"> </font>
                        <li>When<code> t</code> holds one or more locks, then<code> t</code> has a set of <em>priority sources.</em> The <em>active priority</em> for<code> t</code> at any point in time is the maximum of the priorities associated with all of these sources. The priority sources resulting from the monitor control policies defined in this section, and their associated priorities for a schedulable object <code>t</code>, are as follows:
                                <ol type="a">
                                        <li><em>Source:</em> <code>t</code> itself<br>
                                                <em>Associated priority:</em> The base priority for <code>t<br>
                                                </code><em>Note:</em> This may have been changed (either synchronously or asynchronously) while <code>t</code> has been holding its lock(s).<li><em>Source:</em> Each object locked by<code> t</code> and governed by a <code>PriorityCeilingEmulation</code> policy<br>
                                                <em>Associated priority</em>: The maximum value <code>ceil</code> such that <code>ceil</code> is the ceiling for a <code>PriorityCeilingEmulation</code> policy governing an object locked by <code>t.</code> This value is also referred to as the <em>ceiling priority</em> for <code>t</code>.<li><em>Source:</em> Each thread or schedulable object that is attempting to synchronize on an object locked by <code>t</code> and governed by a <code>PriorityInheritance</code> policy<br>
                                                <em>Associated priority:</em> The maximum active priority over all such threads and schedulable objects<br>
                                                <em>Note:</em> This rule accounts for recursive priority inheritance.
                                        <li>Source: Each thread or schedulable object that is attempting to synchronize on an object locked by <code>t</code> and governed by a <code>PriorityCeilingEmulation</code> policy.<br>
                                                <em>Associated priority</em>: The maximum active priority over all such threads and schedulable objects   <br>
                                                <em>Note:</em> This rule, which in effect allows a <code>PriorityCeilingEmulation</code> lock to behave like a <code>PriorityInheritance</code> lock, helps avoid unbounded priority inversions that could otherwise occur in the presence of nested synchronizations involving a mix of <code>PriorityCeilingEmulation</code> and <code>PriorityInheritance</code> policies.
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                        
                                </ol>
                        <li>The addition of a priority source for<code> t</code> either leaves<code> t</code>'s active priority unchanged, or increases it. If<code> t</code>'s active priority is unchanged, then<code> t</code>'s status in its relevant queue (e.g. blocked waiting for some object) is not affected. If <code>t</code>'s active priority is increased, then <code>t</code> is placed at the tail of the relevant queue at its new active priority level.
                        <li>The removal of a priority source for <code>t</code> either leaves <code>t</code>'s active priority unchanged, or decreases it. If <code>t</code>'s active priority is unchanged, then <code>t</code>'s status in its relevant queue (e.g. blocked waiting for some object) is not affected. If <code>t</code>'s active priority is decreased and <code>t</code> is either ready or running, then <code>t</code> must be placed at the head of the ready queue at its new active priority level, if the implementation is supporting <code>PriorityCeilingEmulation</code>.  If the implementation is not supporting <code>PriorityCeilingEmulation</code> then <code>t</code> should be placed at the head of the ready queue at its new active priority (Note the &quot;should&quot;: this behavior is optional.) If <code>PriorityCeilingEmulation</code> is not supported, the implementation must document the queue placement effect. If <code>t</code>'s active priority is decreased and <code>t</code> is blocked, then <code>t</code> is placed in the corresponding queue at its new active priority level. Its position in the queue is implementation defined, but placement at the tail is recommended.</ol>
                <p>The above rules have the following consequences:</p>
                <ul>
                        <li>A thread or schedulable object<code> t</code>'s priority sources from 4.b are added and removed synchronously; i.e., they are established based on <code>t</code>'s entering or leaving synchronized code. However, priority sources from 4.a, 4.c and 4.d may be added and removed asynchronously, as an effect of actions by other threads or schedulable objects.<li>If a thread or schedulable object holds only one lock then, when it releases this lock, its active priority is set to its base priority.
                        <li>A thread or schedulable object's active priority is never less than its base priority.
                        <li>When a thread or schedulable object blocks at a call of <code>obj.wait()</code> it releases the lock on <code>obj</code> and hence relinquishes the priority source(s) based on <code>obj</code>'s monitor control policy. The thread or schedulable object will be queued at a new active priority that reflects the loss of these priority sources.
                </ul>
                Since base priorities may be shared (i.e., the same <code>PriorityParameters</code> object may be associated with multiple schedulable objects), a given base priority may be the active priority for some but not all of its associated schedulable objects.
                
                <p>It is a consequence of other rules that, when a thread or schedulable  object <code>t</code> attempts to synchronize on an object <code>obj</code> governed  by a <code>PriorityCeilingEmulation</code> policy with ceiling <code>ceil</code>, then <code>t</code>'s active priority may exceed <code>ceil</code> but <code>t</code>'s base priority must not. In contrast, once <code>t</code> has successfully synchronized on <code>obj</code> then <code>t</code>'s base priority may also exceed <code>obj</code>'s monitor control policy's ceiling. Note that <code>t</code>'s base priority and/or <code>obj</code>'s monitor control policy may have been dynamically modified.</p>
                <h3>Requirements For Additional Schedulers</h3>
                <p>The following list establishes the semantics and requirements that apply to threads or schedulable objects managed by a scheduler other than the base priority scheduler when they synchronize on objects with monitor control policies defined in this section.</p>
                <ol>
                        <li>An implementation that defines a new <code>Scheduler</code> subclass must document which (if any) monitor control policies the new scheduler does not support.
                        <li>An implementation must document how, if at all, the semantics of synchronization differ from the rules defined for the default <code>PriorityInheritance</code> instance. It must supply documentation for the behavior of the new scheduler with priority inheritance (and, if it is supported, priority ceiling emulation protocol) equivalent to the semantics for the default priority scheduler found in the previous section.
                </ol>
                <h2>Rationale</h2>
                <p>
                Java's rules for <code>synchronized</code> code provide a means 
                for mutual exclusion but do not prevent unbounded priority inversions 
                and thus are insufficient for real-time applications. This 
                specification strengthens the semantics for <code>synchronized</code> 
                code by mandating priority inversion control, in particular by 
                furnishing classes for priority inheritance and priority ceiling 
                emulation. Priority inheritance is more widely implemented in 
                real-time operating systems and thus is required 
                and is the initial default mechanism in this specification.</p>
                <p>Since the same object may be accessed from synchronized code by both a <code>NoHeapRealtimeThread</code> and an arbitrary thread or schedulable object, unwanted dependencies may result. To avoid this problem, this specification provides three wait-free queue classes as an alternative means for safe, concurrent data accesses without priority inversion.</p>
                <p>.</p>
<P>

<P>
<HR>

<HR>

</BODY>
</HTML>

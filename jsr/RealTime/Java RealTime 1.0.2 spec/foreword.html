<html>	<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">	<body>		<h1>Foreword to the First Edition</h1>		I expect <i>The Real-Time Specification for Java</i> to become the first real-time programming language to be both commercially and technologically successful.		<p>Other programming languages have been intended for use in the real-time computing domain. However, none has been commercially successful in the sense of being significantly adopted in that domain. Many were academic research projects. Most did not focus on the core real-time issues of managing computing resources in order to satisfy application timeliness requirements. Instead, they typically emphasized the orthogonal (albeit important) topic of concurrency and other topics important to the whole field of embedded computing systems (of which real-time computing systems are a subset).</p>		<p>Ada 95, including its Real-Time Systems Annex D, has probably been the most successful real-time language, in terms of both adoption and real-time technology. One reason is that Ada is unusually effective (among real-time languages and also operating systems) across the real-time computing system spectrum, from programming-in-the-small in traditional device-level control subsystems, to programming-in-the-large in enterprise command and control systems. Despite that achievement, a variety of nontechnical factors crippled Ada's commercial success.</p>		<p>When James Gosling introduced the Java programming language in 1995, it appeared irrelevant to the real-time computing field, based on most of its initial purposes and its design. Indeed, some of its fundamental principles were antithetical to those of real-time computing. To facilitate its major goal of operating system and hardware independence, the language was deliberately given a weak vocabulary in areas such as thread behavior, synchronization, interrupts, memory management, and input/output. However, these are among the critical areas needing explicit management (by the language or the operating system) for meeting application timeliness requirements.</p>		<p>Nevertheless, the Java platform's promise of &quot;Write Once, Run Anywhere,&quot; together with the Java language's appeal as a programming language <i>per se</i>, offer far greater cost-savings potential in the real-time (and more broadly, the embedded) domain than in the desktop and server domains. Desktops are dominated by the &quot;Wintel&quot; duopoly; servers have only a few processor types and operating systems. Real-time computing systems have tens of different processor types and many tens of different operating system products (not counting the custom-made ones that currently constitute about half of the installations). The POSIX standard hasn't provided the intended real-time application portability because it permits widely varying subsets to be implemented. The Java platform is already almost ubiquitous. The real-time Java platform's necessarily qualified promise of &quot;Write Once Carefully, Run Anywhere Conditionally&quot; is nevertheless the best prospective opportunity for application re-usability.</p>		<p>The overall challenge was to reconcile the intrinsically divergent natures of the Java language and most of real-time computing. Compatibility of the Real-Time Specification for Java and the Java Language Specification had to be maintained, while making the former cost-effective for real-time computing systems.</p>		<p>Most people involved in, and even aware of, the real-time Java effort, including the authors of this book and me, were initially very skeptical about the feasibility of adequately meeting this challenge.</p>		<p>The real-time Java community took two important and unusual initial steps before forming the Real-Time for Java Expert Group under Sun's Java Community Process.</p>		<p>The first step was to convene many representatives of the real-time community a number of times (under the auspices of the National Institute for Standards and Technology), to achieve and document consensus on the requirements for the Real-Time Specification for Java. Not surprisingly, when this consensus emerged, it included mandatory requirements for building the kind of smaller scale, static, real-time subsystems familiar to current practitioners using C and C++.</p>		<p>More surprisingly, the consensus also included mandatory and optional requirements for accommodating advanced dynamic and real-time resource management technologies, such as asynchronous transfer of control and timeliness-based scheduling policies, and for building larger scale real-time systems. The primary impetus for these dynamic and programming-in-the-large, real-time requirements came from the communities already using the Java language, or using the Ada language, or building defense (primarily command and control) systems.</p>		<p>The second, concomitant, step was to establish an agreed-upon lexicon of real-time computing concepts and terms to enable this dialog about, and consensus on, the requirements for the Real-Time Specification for Java. As unlikely as it may seem to those outside of the real-time community, real-time computing concepts and terms are normally not used in a well-defined way (except by most real-time researchers).</p>		<p>The next step toward the realization of the Java language's potential for the present and the future of real-time computing is defining and writing the Real-Time Specification for Java, the first version of which is in this book. Understanding this specification will also improve the readers' understanding of both the Java language and real-time computing systems as well.</p>		<p>Greg Bollella was an ideal leader for this specification team. He recruited a well balanced group of real-time and Java language experts. His background in both practical and theoretical real-time computing prepared him for gently but resolutely guiding the team's rich and intense discussions into a coherent specification.</p>		<p>Of course, more work remains, including documenting use cases and examples; performing implementations and evaluations; gaining experience from deployed products; and iterations on <i>The Real-Time Specification for Java.</i> The Distributed Real-Time Specification for Java also lies ahead.</p>		<p>The real-time Java platform is prepared not just to provide cost-reduced functional parity with current mainstream real-time computing practice and products, but also to play a leadership role as real-time computing practice moves forward in the Internet age.<i></i></p>		<p><i>E. Douglas Jensen</i><br>			<i>Sherborn, MA</i></p>	</body></html>
<html>

	<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">

	<body>
		<h1>Introduction</h1>
		<p>The Real-Time for Java Expert Group (RTJEG), convened under the Java Community Process and JSR-000001, was given the responsibility of producing a specification for extending <i>The Java Language Specification</i> and <i>The Java Virtual Machine Specification</i> and of providing an Application Programming Interface that will enable the creation, verification, analysis, execution, and management of Java threads whose correctness conditions include timeliness constraints (also known as real-time threads). This introduction describes the guiding principles that the RTJEG created and used during their work, a description of the real-time Java requirements developed under the auspices of The National Institute for Standards and Technology (NIST), and a brief, high-level description of each of the seven areas identified as requiring enhancements to accomplish the Expert Group's goals.</p>
		<h2>Guiding Principles</h2>
		The guiding principles are high-level statements that delimit the scope of the work of the RTJEG and introduce compatibility requirements for <i>The Real-Time Specification for Java.</i>
		<p><b>Applicability to Particular Java Environments:</b> The RTSJ shall not include specifications that restrict its use to particular Java environments, such as a particular version of the Java Development Kit, the Embedded Java Application Environment, or the Java 2 Micro Edition&#153;.</p>
		<p><b>Backward Compatibility:</b> The RTSJ shall not prevent existing, properly written, non-real-time Java programs from executing on implementations of the RTSJ.</p>
		<p><b>Write Once, Run Anywhere:</b> The RTSJ should recognize the importance of &quot;Write Once, Run Anywhere&quot;, but it should also recognize the difficulty of achieving WORA for real-time programs and not attempt to increase or maintain binary portability at the expense of predictability.</p>
		<p><b>Current Practice vs. Advanced Features:</b> The RTSJ should address current real-time system practice as well as allow future implementations to include advanced features.</p>
		<p><b>Predictable Execution:</b> The RTSJ shall hold predictable execution as first priority in all trade-offs; this may sometimes be at the expense of typical general-purpose computing performance measures.</p>
		<p><b>No Syntactic Extension: </b>In order to facilitate the job of tool developers, and thus to increase the likelihood of timely implementations, the RTSJ shall not introduce new keywords or make other syntactic extensions to the Java language.</p>
		<p><b>Allow Variation in Implementation Decisions: </b>The RTJEG recognizes that implementations of the RTSJ may vary in a number of implementation decisions, such as the use of efficient or inefficient algorithms, trade-offs between time and space efficiency, inclusion of scheduling algorithms not required in the minimum implementation, and variation in code path length for the execution of byte codes. The RTSJ should not mandate algorithms or specific time constants for such, but require that the semantics of the implementation be met. The RTSJ offers implementers the flexibility to create implementations suited to meet the requirements of their customers.</p>
		<h2>Overview of the Seven Enhanced Areas</h2>
		In each of the seven sections that follow we give a brief statement of direction for each area. These directions were defined at the first meeting of the eight primary engineers in Mendocino, California, in late March 1999, and further clarified through late September 1999.
		<p><b>Thread Scheduling and Dispatching:</b> In light of the significant diversity in scheduling and dispatching models and the recognition that each model has wide applicability in the diverse real-time systems industry, we concluded that our direction for a scheduling specification would be to allow an underlying scheduling mechanism to be used by real-time Java threads but that we would not specify in advance the nature of all (or even a number of) possible scheduling mechanisms. The specification is constructed to allow implementations to provide unanticipated scheduling algorithms. Implementations will allow the programmatic assignment of parameters appropriate for the underlying scheduling mechanism as well as providing any necessary methods for the creation, management, admittance, and termination of real-time Java threads. We also expect that, for now, particular thread scheduling and dispatching mechanisms are bound to an implementation. However, we provide enough flexibility in the thread scheduling framework to allow future versions of the specification to build on this release and allow the dynamic loading of scheduling policy modules.</p>
		<p>To accommodate current practice the RTSJ requires a base scheduler in all implementations. The required base scheduler will be familiar to real-time system programmers. It is priority-based, preemptive, and must have at least 28 unique priorities.</p>
		<p><b>Memory Management:</b> We recognize that automatic memory management is a particularly important feature of the Java programming environment, and we sought a direction that would allow, as much as possible, the job of memory management to be implemented automatically by the underlying system and not intrude on the programming task. Additionally, we understand that many automatic memory management algorithms, also known as garbage collection (GC), exist, and many of those apply to certain classes of real-time programming styles and systems.&nbsp; In our attempt to accommodate a diverse set of GC algorithms, we sought&nbsp; to define a memory allocation and reclamation specification that would:</p>
		<ul>
			<li>be independent of any particular GC algorithm,
			<li>allow the program to precisely characterize a implemented GC algorithm's effect on the execution time, preemption, and dispatching of real-time Java threads, and
			<li>allow the allocation and reclamation of objects outside of any interference by any GC algorithm.&nbsp;
		</ul>
		<p><b>Synchronization and Resource Sharing:</b> Logic often requires serial access to resources. Real-time systems introduce an additional complexity: controlling priority inversion. We have decided that the least intrusive specification for allowing real-time safe synchronization is to require that implementations of the Java keyword <tt>synchronized</tt>&nbsp; include one or more algorithms that prevent priority inversion among real-time Java threads that share the serialized resource. We also note that in some cases the use of the <tt>synchronized</tt> keyword implementing the required priority inversion algorithm is not sufficient to both prevent priority inversion and allow a thread to have an execution eligibility logically higher than the garbage collector. We provide a set of wait-free queue classes to be used in such situations.</p>
		<p><b>Asynchronous Event Handling:</b> Real-time systems typically interact closely with the real-world. With respect to the execution of logic, the real-world is asynchronous. We thus felt compelled to include efficient mechanisms for programming disciplines that would accommodate this inherent asynchrony. The RTSJ generalizes the Java language's mechanism of asynchronous event handling. Required classes represent things that can happen and logic that executes when those things happen. A notable feature is that the execution of the logic is scheduled and dispatched by an implemented scheduler.</p>
		<p><b>Asynchronous Transfer of Control:</b> Sometimes the real-world changes so drastically (and asynchronously) that the current point of logic execution should be immediately and efficiently transferred to another location. The RTSJ includes a mechanism which extends Java's exception handling to allow applications to programatically change the locus of control of another Java thread. It is important to note that the RTSJ restricts this asynchronous transfer of control to logic specifically written with the assumption that its locus of control may asynchronously change.</p>
		<p><b>Asynchronous Thread Termination:</b> Again, due to the sometimes drastic and asynchronous changes in the real-world, application logic may need to arrange for a real-time Java thread to expeditiously and safely transfer its control to its outermost scope and thus end in a normal manner. Note that unlike the traditional, unsafe, and deprecated Java mechanism for stopping threads, the RTSJ's mechanism for asynchronous event handling and transfer of control is safe.</p>
		<p><b>Physical Memory Access:</b> Although not directly a real-time issue, physical memory access is desirable for many of the applications that could productively make use of an implementation of the RTSJ. We thus define a class that allows programmers byte-level access to physical memory as well as a class that allows the construction of objects in physical memory.</p>
	</body>

</html>
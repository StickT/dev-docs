<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_06) on Mon Jun 26 19:39:54 EDT 2006 -->
<TITLE>
WaitFreeWriteQueue (Synchronization)
</TITLE>

<META NAME="keywords" CONTENT="javax.realtime.WaitFreeWriteQueue class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="WaitFreeWriteQueue (Synchronization)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.realtime</FONT>
<BR>
Class WaitFreeWriteQueue</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>javax.realtime.WaitFreeWriteQueue</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>WaitFreeWriteQueue</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
A queue that can be non-blocking for producers.
 The <code>WaitFreeWriteQueue</code> class is intended for single-writer 
    multiple-reader communication, although it may also be used (with care) 
    for multiple writers.  A <em>writer</em> is generally an instance of 
    <A HREF="../../javax/realtime/NoHeapRealtimeThread.html" title="class in javax.realtime"><CODE>NoHeapRealtimeThread</CODE></A>, and the <em>readers</em> 
    are generally regular Java 
    threads or heap-using real-time threads or schedulable objects.  Communication is through a 
    bounded buffer of Objects that is managed first-in-first-out.  The 
    principal methods for this class are write and read 
 </P><P>
 <UL>
 <LI> The <CODE>write</CODE> method appends a new element onto the queue.
 It is not synchronized, and does not block when the queue
 is full (it returns <CODE>false</CODE> instead).
 Multiple writer threads or schedulable objects
  are permitted, but if two or more 
 threads intend to write to the same
 <CODE>WaitFreeWriteQueue</CODE> they will need to arrange explicit synchronization.
 </li>
   
 <LI> The <CODE>read</CODE> method removes the oldest element from the queue.
 It is synchronized, and will block when the queue is empty.
 It may be called by more than one reader, in which case the different callers
 will read different elements from the queue.
 </UL>
 <p>
 <CODE>WaitFreeWriteQueue</CODE> is one of the classes allowing
 <CODE>NoHeapRealtimeThread</CODE>s and regular Java threads to synchronize on an object
 without the risk of a <CODE>NoHeapRealtimeThread</CODE> incurring Garbage Collector latency
 due to priority inversion avoidance management.
 </P>

<I>Incompatibility with V1.0:</I>
Three exceptions previously thrown by the constructor have been deleted from
the <CODE>throws</CODE> clause.  These are:
</P><P>

<UL>
<LI><CODE>java.lang.IllegalAccessException</CODE>,
<LI><CODE>java.lang.ClassNotFoundException</CODE>, and
<LI><CODE>java.lang.InstantiationException</CODE>.
</UL>
<P>

Including these exceptions on the <CODE>throws</CODE> clause was an error.
Their
deletion may cause compile-time errors in code using the previous constructor.
The repair is to remove the exceptions from the <CODE>catch</CODE> clause around
the constructor invocation.
</P>
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/realtime/WaitFreeWriteQueue.html#WaitFreeWriteQueue(int)">WaitFreeWriteQueue</A></B>(int&nbsp;maximum)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a queue containing up to <code>maximum</code>
 elements in immortal memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/realtime/WaitFreeWriteQueue.html#WaitFreeWriteQueue(int, javax.realtime.MemoryArea)">WaitFreeWriteQueue</A></B>(int&nbsp;maximum,
                   <A HREF="../../javax/realtime/MemoryArea.html" title="class in javax.realtime">MemoryArea</A>&nbsp;memory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a queue containing up to <code>maximum</code>
 elements in <code>memory</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/realtime/WaitFreeWriteQueue.html#WaitFreeWriteQueue(java.lang.Runnable, java.lang.Runnable, int, javax.realtime.MemoryArea)">WaitFreeWriteQueue</A></B>(java.lang.Runnable&nbsp;writer,
                   java.lang.Runnable&nbsp;reader,
                   int&nbsp;maximum,
                   <A HREF="../../javax/realtime/MemoryArea.html" title="class in javax.realtime">MemoryArea</A>&nbsp;memory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a queue in <code>memory</code> with an unsynchronized and 
 nonblocking <code>write()</code> method and a
 synchronized and blocking <code>read()</code> method.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/WaitFreeWriteQueue.html#clear()">clear</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets <code>this</code> to empty.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/WaitFreeWriteQueue.html#force(java.lang.Object)">force</A></B>(java.lang.Object&nbsp;object)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unconditionally insert <code>object</code> into <code>this</code>, 
 either in a vacant position 
 or else overwriting the most recently inserted element.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/WaitFreeWriteQueue.html#isEmpty()">isEmpty</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queries the system to determine if <code>this</code> is empty.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/WaitFreeWriteQueue.html#isFull()">isFull</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queries the system to determine if <code>this</code> is full.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/WaitFreeWriteQueue.html#read()">read</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A synchronized and possibly blocking operation on the queue.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/WaitFreeWriteQueue.html#size()">size</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queries the queue to determine the number of elements in <code>this</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/WaitFreeWriteQueue.html#write(java.lang.Object)">write</A></B>(java.lang.Object&nbsp;object)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inserts <code>object</code> into <code>this</code> if 
 <code>this</code> is non-full and otherwise 
 has no effect on <code>this</code>; the 
 <code>boolean</code> result reflects whether 
 <code>object</code> has been inserted.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="WaitFreeWriteQueue(java.lang.Runnable, java.lang.Runnable, int, javax.realtime.MemoryArea)"><!-- --></A><H3>
WaitFreeWriteQueue</H3>
<PRE>
public <B>WaitFreeWriteQueue</B>(java.lang.Runnable&nbsp;writer,
                          java.lang.Runnable&nbsp;reader,
                          int&nbsp;maximum,
                          <A HREF="../../javax/realtime/MemoryArea.html" title="class in javax.realtime">MemoryArea</A>&nbsp;memory)</PRE>
<DL>
<DD>Constructs a queue in <code>memory</code> with an unsynchronized and 
 nonblocking <code>write()</code> method and a
 synchronized and blocking <code>read()</code> method.
 <p>
 The <code>writer</code> and <code>reader</code> parameters, if non-null,
 are checked to insure that they are compatible with the <code>MemoryArea</code>
 specified by <code>memory</code> (if non-null.)  If <code>memory</code> is null
 and both Runnables are non-null, the constructor will select the 
 nearest common scoped parent memory area, or
 if there is no such scope it will use immortal memory.
 If all three parameters are null, the queue will be
 allocated in immortal memory.
 <p>
 <code>reader</code> and <code>writer</code>
  are not necessarily the only threads or
  schedulable objects that will access the queues; moreover,
 there is no check that they actually access the queue at all.
 <p>
 <em>Note:</em> that the wait free queue's internal queue is allocated in 
 <code>memory,</code> but the memory area of the wait free queue instance itself
 is determined by the current allocation context.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>writer</CODE> - An instance of <CODE>Thread</CODE>, a schedulable
 object, or null.<DD><CODE>reader</CODE> - An instance of <CODE>Thread</CODE>, a schedulable
 object, or null.<DD><CODE>maximum</CODE> - The maximum number of elements in the queue.<DD><CODE>memory</CODE> - The <A HREF="../../javax/realtime/MemoryArea.html" title="class in javax.realtime"><CODE>MemoryArea</CODE></A> in which this object and internal elements are
        allocated.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if an argument holds an invalid value. 
          The <code>writer</code> argument must be null, a reference to
          a <code>Thread</code>, or a reference to a schedulable object
          (a <code>RealtimeThread</code>, or an <code>AsyncEventHandler</code>.)
          The <code>reader</code> argument must  be null, a reference to
          a <code>Thread</code>, or a reference to a schedulable object.
          The <code>maximum</code> argument must be greater than zero.
<DD><CODE><A HREF="../../javax/realtime/MemoryScopeException.html" title="class in javax.realtime">MemoryScopeException</A></CODE> - Thrown if 
          either <code>reader</code> or <code>writer</code>
          is non-null and the <code>memory</code> argument is not 
          compatible with <code>reader</code> and
          <code>writer</code> with respect to the assignment 
          and access rules for memory areas.
<DD><CODE><A HREF="../../javax/realtime/InaccessibleAreaException.html" title="class in javax.realtime">InaccessibleAreaException</A></CODE> - Thrown if <code>memory</code> is a scoped
                        memory that is not on the caller's scope stack.</DL>
</DL>
<HR>

<A NAME="WaitFreeWriteQueue(int, javax.realtime.MemoryArea)"><!-- --></A><H3>
WaitFreeWriteQueue</H3>
<PRE>
public <B>WaitFreeWriteQueue</B>(int&nbsp;maximum,
                          <A HREF="../../javax/realtime/MemoryArea.html" title="class in javax.realtime">MemoryArea</A>&nbsp;memory)</PRE>
<DL>
<DD>Constructs a queue containing up to <code>maximum</code>
 elements in <code>memory</code>.  The queue has an unsynchronized and 
 nonblocking <code>write()</code> method and a
 synchronized and blocking <code>read()</code> method.
 <p>
 <em>Note:</em> that the wait free queue's internal queue is allocated in 
 <code>memory,</code> but the memory area of the wait free queue instance itself
 is determined by the current allocation context.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>maximum</CODE> - The maximum number of elements in the queue.<DD><CODE>memory</CODE> - The <A HREF="../../javax/realtime/MemoryArea.html" title="class in javax.realtime"><CODE>MemoryArea</CODE></A> in which this object and internal elements are
        allocated.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if
          the <code>maximum</code> argument is less than or equal to zero,
          or <code>memory</code> is null.
<DD><CODE><A HREF="../../javax/realtime/InaccessibleAreaException.html" title="class in javax.realtime">InaccessibleAreaException</A></CODE> - Thrown if <code>memory</code> is a scoped
          memory that is not on the caller's scope stack.<DT><B>Since:</B></DT>
  <DD>1.0.1</DD>
</DL>
</DL>
<HR>

<A NAME="WaitFreeWriteQueue(int)"><!-- --></A><H3>
WaitFreeWriteQueue</H3>
<PRE>
public <B>WaitFreeWriteQueue</B>(int&nbsp;maximum)</PRE>
<DL>
<DD>Constructs a queue containing up to <code>maximum</code>
 elements in immortal memory.  The queue has an unsynchronized and 
 nonblocking <code>write()</code> method and a
 synchronized and blocking <code>read()</code> method.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>maximum</CODE> - The maximum number of elements in the queue.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if
          the <code>maximum</code> argument is less than or equal to zero.<DT><B>Since:</B></DT>
  <DD>1.0.1</DD>
</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="clear()"><!-- --></A><H3>
clear</H3>
<PRE>
public void <B>clear</B>()</PRE>
<DL>
<DD>Sets <code>this</code> to empty.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isEmpty()"><!-- --></A><H3>
isEmpty</H3>
<PRE>
public boolean <B>isEmpty</B>()</PRE>
<DL>
<DD>Queries the system to determine if <code>this</code> is empty.
 <p>
 <em>Note:</em> This method needs to be used with care since the state of the queue
 may change while the method is in progress or after it has returned.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>True, if <code>this</code> is empty. 
         False, if <code>this</code> is not empty.</DL>
</DD>
</DL>
<HR>

<A NAME="isFull()"><!-- --></A><H3>
isFull</H3>
<PRE>
public boolean <B>isFull</B>()</PRE>
<DL>
<DD>Queries the system to determine if <code>this</code> is full.
 <p>
 <em>Note:</em> This method needs to be used with care since the state of the queue
 may change while the method is in progress or after it has returned.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>True, if <code>this</code> is full. 
         False, if <code>this</code> is not full.</DL>
</DD>
</DL>
<HR>

<A NAME="read()"><!-- --></A><H3>
read</H3>
<PRE>
public java.lang.Object <B>read</B>()
                      throws java.lang.InterruptedException</PRE>
<DL>
<DD>A synchronized and possibly blocking operation on the queue.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The <CODE>Object</CODE> least recently written to the queue.
 If <code>this</code> is empty, the calling thread or schedulable
  objects blocks until
 an element is inserted; when it is resumed, <code>read</code>
 removes and returns the element.
<DT><B>Throws:</B>
<DD><CODE>java.lang.InterruptedException</CODE> - Thrown if the thread is interrupted
         by <code>interrupt()</code> or <A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#fire()"><CODE>AsynchronouslyInterruptedException.fire()</CODE></A> during
         the time between calling this method and returning from it.<DT><B>Since:</B></DT>
  <DD>1.0.1 Throws <code>InterruptedException</code></DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="size()"><!-- --></A><H3>
size</H3>
<PRE>
public int <B>size</B>()</PRE>
<DL>
<DD>Queries the queue to determine the number of elements in <code>this</code>.
 <p>
 <em>Note:</em> This method needs to be used with care since the state of the queue
 may change while the method is in progress or after it has returned.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The number of positions in <code>this</code> occupied by 
  elements that have been written but not yet read.</DL>
</DD>
</DL>
<HR>

<A NAME="force(java.lang.Object)"><!-- --></A><H3>
force</H3>
<PRE>
public boolean <B>force</B>(java.lang.Object&nbsp;object)</PRE>
<DL>
<DD>Unconditionally insert <code>object</code> into <code>this</code>, 
 either in a vacant position 
 or else overwriting the most recently inserted element. The 
 <code>boolean</code> result reflects whether, at the time that <code>force()</code> 
 returns, the position at which <code>object</code> was inserted was 
 vacant (<code>false</code>) or occupied (<code>true</code>).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>object</CODE> - A non-null <code>java.lang.Object</code> to insert.
<DT><B>Returns:</B><DD><code>true</code> if <code>object</code> has overwritten 
 an element that was occupied when the function returns; 
 <code>false</code> otherwise (it has been inserted 
 into a position that was vacant when the function returns)
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/MemoryScopeException.html" title="class in javax.realtime">MemoryScopeException</A></CODE> - Thrown if a memory access error 
                or illegal assignment error would occur 
                while storing <code>object</code> in the queue.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if <code>object</code> is null.</DL>
</DD>
</DL>
<HR>

<A NAME="write(java.lang.Object)"><!-- --></A><H3>
write</H3>
<PRE>
public boolean <B>write</B>(java.lang.Object&nbsp;object)</PRE>
<DL>
<DD>Inserts <code>object</code> into <code>this</code> if 
 <code>this</code> is non-full and otherwise 
 has no effect on <code>this</code>; the 
 <code>boolean</code> result reflects whether 
 <code>object</code> has been inserted. If the queue was empty and 
 one or more threads or schedulable objects were waiting to read, then one will 
 be awakened after the write. The choice of which to awaken 
 depends on the involved scheduler(s).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>object</CODE> - A non-null <code>java.lang.Object</code> to insert.
<DT><B>Returns:</B><DD><code>true</code> if the queue was non-full;
         <code>false</code> otherwise.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/MemoryScopeException.html" title="class in javax.realtime">MemoryScopeException</A></CODE> - Thrown if a memory access error 
                or illegal assignment error would occur 
                while storing <code>object</code> in the queue.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if <code>object</code> is null.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<HR>

</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_06) on Mon Jun 26 19:39:53 EDT 2006 -->
<TITLE>
RawMemoryFloatAccess (Synchronization)
</TITLE>

<META NAME="keywords" CONTENT="javax.realtime.RawMemoryFloatAccess class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="RawMemoryFloatAccess (Synchronization)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.realtime</FONT>
<BR>
Class RawMemoryFloatAccess</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><A HREF="../../javax/realtime/RawMemoryAccess.html" title="class in javax.realtime">javax.realtime.RawMemoryAccess</A>
      <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>javax.realtime.RawMemoryFloatAccess</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>RawMemoryFloatAccess</B><DT>extends <A HREF="../../javax/realtime/RawMemoryAccess.html" title="class in javax.realtime">RawMemoryAccess</A></DL>
</PRE>

<P>
This class holds the accessor methods for accessing a raw memory area
 by float and double types. Implementations are required to implement
 this class if and only if the underlying Java Virtual Machine supports
 floating point data types.
 <p> 
  By default, the byte addressed by <code>offset</code> is the byte at the
  lowest address of the
  floating point processor's floating point representation.
  If the type of memory used for this 
  <code>RawMemoryFloatAccess</code> region implements a non-standard floating
  point format, accessor methods in this class continue to select bytes 
  starting at <code>offset</code> from the base address and continuing toward 
  greater addresses.  The memory type may control the mapping of these bytes into 
  the primitive data type.  The memory type could even select bytes that are not
  contiguous.  In each case the documentation for the <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html" title="interface in javax.realtime"><CODE>PhysicalMemoryTypeFilter</CODE></A>
  must document any mapping other than the "normal" one specified above.
 <p> 
  <p>
  All offset values used in this class are measured in bytes.
  <p>
  Atomic loads and stores on raw memory are defined in terms of 
  physical memory.  This memory may be accessible to threads outside the
  JVM and to non-programmed access (e.g., DMA), consequently atomic
  access must be supported by hardware.  This specification
  is written with the assumption that all suitable hardware platforms
  support atomic loads for aligned floats.  
  Atomic access beyond the specified minimum may be supported by the implementation.
  <p>
  Storing values into raw memory is more hardware-dependent than loading values.
  Many processor architectures do not support atomic stores of variables except for
  aligned stores of the processor's word size.
 <p>
  This class supports unaligned access to data, but it does
  not require the implementation to make such access atomic.  Accesses to
  data aligned on its natural boundary will be atomic if the processor
  implements atomic loads and stores of that data size.
  <p>
  Except where noted, accesses to raw memory are not atomic with respect to the memory
  or with respect to threads.  A raw memory area could be updated by another thread, or
  even unmapped in the middle of a method.
  <p>
  The characteristics of raw-memory access are necessarily platform dependent.
  This specification provides a minimum requirement for the RTSJ platform, but it also
  supports a optional system properties that identify a platform's level of support for atomic 
  raw put and get.  (See <A HREF="../../javax/realtime/RawMemoryAccess.html" title="class in javax.realtime"><CODE>RawMemoryAccess</CODE></A>.) The properties represent a four-dimensional sparse array with boolean values
  whether that combination of access attributes is atomic.  The default value for array entries is
  false.
  <p>
  Many of the constructors and methods in this class throw 
 <A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime"><CODE>OffsetOutOfBoundsException</CODE></A>.  This exception means that the 
 value given in the offset parameter is either negative or outside the
 memory area.
 
 <p> Many of the constructors and methods in this class throw 
 <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A>.  This exception means that the value
 given in the size parameter is either negative, larger than an allowable
 range, or would cause an accessor method to access an address outside of
 the memory area.
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryFloatAccess.html#RawMemoryFloatAccess(java.lang.Object, long)">RawMemoryFloatAccess</A></B>(java.lang.Object&nbsp;type,
                     long&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construct an instance of <code>RawMemoryFloatAccess</code> with the given parameters,
  and set the object to the mapped state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryFloatAccess.html#RawMemoryFloatAccess(java.lang.Object, long, long)">RawMemoryFloatAccess</A></B>(java.lang.Object&nbsp;type,
                     long&nbsp;base,
                     long&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construct an instance of <code>RawMemoryFloatAccess</code> with the given parameters,
  and set the object to the mapped state.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryFloatAccess.html#getDouble(long)">getDouble</A></B>(long&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the <code>double</code> at the given offset in the memory area
  associated with this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryFloatAccess.html#getDoubles(long, double[], int, int)">getDoubles</A></B>(long&nbsp;offset,
           double[]&nbsp;doubles,
           int&nbsp;low,
           int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets <code>number</code> doubles starting at the given offset in the memory area
  associated with this object and assign 
 them to the double array passed starting at position <code>low</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryFloatAccess.html#getFloat(long)">getFloat</A></B>(long&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the <code>float</code> at the given offset in the memory area
  associated with this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryFloatAccess.html#getFloats(long, float[], int, int)">getFloats</A></B>(long&nbsp;offset,
          float[]&nbsp;floats,
          int&nbsp;low,
          int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets <code>number</code> floats starting at the given offset in the memory area
  associated with this object and assign 
 them to the int array passed starting at position <code>low</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryFloatAccess.html#setDouble(long, double)">setDouble</A></B>(long&nbsp;offset,
          double&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <code>double</code> at the given offset in the memory area
  associated with this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryFloatAccess.html#setDoubles(long, double[], int, int)">setDoubles</A></B>(long&nbsp;offset,
           double[]&nbsp;doubles,
           int&nbsp;low,
           int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets <code>number</code> doubles starting at the given offset in the memory area
  associated with this object from the 
 double array passed starting at position <code>low</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryFloatAccess.html#setFloat(long, float)">setFloat</A></B>(long&nbsp;offset,
         float&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <code>float</code> at the given offset in the memory area
  associated with this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryFloatAccess.html#setFloats(long, float[], int, int)">setFloats</A></B>(long&nbsp;offset,
          float[]&nbsp;floats,
          int&nbsp;low,
          int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets <code>number</code> floats starting at the given offset in the memory area
  associated with this object from the 
 float array passed starting at position <code>low</code>.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.realtime.RawMemoryAccess"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class javax.realtime.<A HREF="../../javax/realtime/RawMemoryAccess.html" title="class in javax.realtime">RawMemoryAccess</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../javax/realtime/RawMemoryAccess.html#getByte(long)">getByte</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#getBytes(long, byte[], int, int)">getBytes</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#getInt(long)">getInt</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#getInts(long, int[], int, int)">getInts</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#getLong(long)">getLong</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#getLongs(long, long[], int, int)">getLongs</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#getMappedAddress()">getMappedAddress</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#getShort(long)">getShort</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#getShorts(long, short[], int, int)">getShorts</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#map()">map</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long)">map</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)">map</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#setByte(long, byte)">setByte</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#setBytes(long, byte[], int, int)">setBytes</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#setInt(long, int)">setInt</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#setInts(long, int[], int, int)">setInts</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#setLong(long, long)">setLong</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#setLongs(long, long[], int, int)">setLongs</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#setShort(long, short)">setShort</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#setShorts(long, short[], int, int)">setShorts</A>, <A HREF="../../javax/realtime/RawMemoryAccess.html#unmap()">unmap</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="RawMemoryFloatAccess(java.lang.Object, long)"><!-- --></A><H3>
RawMemoryFloatAccess</H3>
<PRE>
public <B>RawMemoryFloatAccess</B>(java.lang.Object&nbsp;type,
                            long&nbsp;size)</PRE>
<DL>
<DD>Construct an instance of <code>RawMemoryFloatAccess</code> with the given parameters,
  and set the object to the mapped state.
  If the platform supports virtual memory, map
  the raw memory into virtual memory.
 <p>
  The run time environment is allowed to choose the virtual address where
  the raw memory area corresponding to this object will be mapped.  The 
  attributes of the mapping operation are controlled by the vMFlags and 
  vMAttributes of the <code>PhysicalMemoryTypeFilter</code> objects 
  that matched this object's <code>type</code> parameter.  (See 
  <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html#getVMAttributes()"><CODE>PhysicalMemoryTypeFilter.getVMAttributes()</CODE></A> 
  and <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html#getVMFlags()"><CODE>PhysicalMemoryTypeFilter.getVMFlags()</CODE></A>.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - An instance of <code>Object</code> representing the type of
        memory required (e.g., <em>dma, shared</em>) - used to define the base address
              and control the mapping.  If the required memory has more than one
      attribute, <code>type</code> may be an array of objects.    If <code>type</code>
      is null or a reference to an array with no entries, any type of memory
      is acceptable. Note that <code>type</code> values are compared by 
      reference (==), not by value (<code>equals</code>).<DD><CODE>size</CODE> - The size of the area in bytes.
<DT><B>Throws:</B>
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if the application doesn't have
            permissions to access physical memory, the
              specified range of addresses, or the given type of memory.
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the size is negative or
            extends into an invalid range of memory.
<DD><CODE><A HREF="../../javax/realtime/UnsupportedPhysicalMemoryException.html" title="class in javax.realtime">UnsupportedPhysicalMemoryException</A></CODE> - Thrown if the underlying 
            hardware does not support the given type, or if no matching
          <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html" title="interface in javax.realtime"><CODE>PhysicalMemoryTypeFilter</CODE></A> has been registered with
          the <A HREF="../../javax/realtime/PhysicalMemoryManager.html" title="class in javax.realtime"><CODE>PhysicalMemoryManager</CODE></A>.
<DD><CODE><A HREF="../../javax/realtime/MemoryTypeConflictException.html" title="class in javax.realtime">MemoryTypeConflictException</A></CODE> - Thrown if the specified base does not point to
            memory that matches the request type, or if <code>type</code> specifies
            incompatible memory attributes.
<DD><CODE>java.lang.OutOfMemoryError</CODE> - Thrown if the requested type of memory exists, but there is not
      enough of it free to satisfy the request.</DL>
</DL>
<HR>

<A NAME="RawMemoryFloatAccess(java.lang.Object, long, long)"><!-- --></A><H3>
RawMemoryFloatAccess</H3>
<PRE>
public <B>RawMemoryFloatAccess</B>(java.lang.Object&nbsp;type,
                            long&nbsp;base,
                            long&nbsp;size)</PRE>
<DL>
<DD>Construct an instance of <code>RawMemoryFloatAccess</code> with the given parameters,
  and set the object to the mapped state.
  If the platform supports virtual memory, map
  the raw memory into virtual memory.
 <p>
  The run time environment is allowed to choose the virtual address where
  the raw memory area corresponding to this object will be mapped.  The 
  attributes of the mapping operation are controlled by the vMFlags and 
  vMAttributes of the <code>PhysicalMemoryTypeFilter</code> objects 
  that matched this object's <code>type</code> parameter.  (See 
  <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html#getVMAttributes()"><CODE>PhysicalMemoryTypeFilter.getVMAttributes()</CODE></A> 
  and <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html#getVMFlags()"><CODE>PhysicalMemoryTypeFilter.getVMFlags()</CODE></A>.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - An instance of <code>Object</code> representing the type of
        memory required (e.g., <em>dma, shared</em>) - used to define the base address
              and control the mapping.  If the required memory has more than one
      attribute, <code>type</code> may be an array of objects.    If <code>type</code>
      is null or a reference to an array with no entries, any type of memory
      is acceptable. Note that <code>type</code> values are compared by 
      reference (==), not by value (<code>equals</code>).<DD><CODE>base</CODE> - The physical memory address of the region.<DD><CODE>size</CODE> - The size of the area in bytes.
<DT><B>Throws:</B>
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if the application doesn't have
            permissions to access physical memory, the
              specified range of addresses, or the given type of memory.
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the address is invalid.
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the size is negative or
            extends into an invalid range of memory.
<DD><CODE><A HREF="../../javax/realtime/UnsupportedPhysicalMemoryException.html" title="class in javax.realtime">UnsupportedPhysicalMemoryException</A></CODE> - Thrown if the underlying 
            hardware does not support the given type, or if no matching
          <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html" title="interface in javax.realtime"><CODE>PhysicalMemoryTypeFilter</CODE></A> has been registered with
          the <A HREF="../../javax/realtime/PhysicalMemoryManager.html" title="class in javax.realtime"><CODE>PhysicalMemoryManager</CODE></A>.
<DD><CODE><A HREF="../../javax/realtime/MemoryTypeConflictException.html" title="class in javax.realtime">MemoryTypeConflictException</A></CODE> - Thrown if the specified base does not point to
            memory that matches the request type, or if <code>type</code> specifies
            incompatible memory attributes.
<DD><CODE>java.lang.OutOfMemoryError</CODE> - Thrown if the requested type of memory exists, but there is not</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getDouble(long)"><!-- --></A><H3>
getDouble</H3>
<PRE>
public double <B>getDouble</B>(long&nbsp;offset)</PRE>
<DL>
<DD>Gets the <code>double</code> at the given offset in the memory area
  associated with this object.
 <p>
  The load is not required to be atomic even it is located on a natural boundary.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
      from which to load the long.
<DT><B>Returns:</B><DD>The double from raw memory.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is invalid.
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the double falls in an invalid address range.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="getDoubles(long, double[], int, int)"><!-- --></A><H3>
getDoubles</H3>
<PRE>
public void <B>getDoubles</B>(long&nbsp;offset,
                       double[]&nbsp;doubles,
                       int&nbsp;low,
                       int&nbsp;number)</PRE>
<DL>
<DD>Gets <code>number</code> doubles starting at the given offset in the memory area
  associated with this object and assign 
 them to the double array passed starting at position <code>low</code>.
 <p>
  The loads are not required to be atomic even if they are located on natural boundaries.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
      at which to start loading.<DD><CODE>doubles</CODE> - The array into which the loaded items are placed.<DD><CODE>low</CODE> - The offset which is the starting point in the given array for the
            loaded items to be placed.<DD><CODE>number</CODE> - The number of doubles to load.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <code>SizeOutOfBoundsException</code> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>RawMemoryAccess.map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if a double falls in an invalid address range.  This is checked at every
      entry in the array to allow for the possibility that the memory area
      could be unmapped or remapped.  The <code>doubles</code> array could, therefore, be
      partially updated if the raw memory is unmapped or remapped mid-method.
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - Thrown if <code>low</code> is less than 0 or greater
                than <code>bytes.length - 1</code>, or if <code>low + number</code> is greater than or 
                equal to <code>bytes.length</code>.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="getFloat(long)"><!-- --></A><H3>
getFloat</H3>
<PRE>
public float <B>getFloat</B>(long&nbsp;offset)</PRE>
<DL>
<DD>Gets the <code>float</code> at the given offset in the memory area
  associated with this object.  If the float is aligned on a "natural"
  boundary it is always loaded from memory
  in a single atomic operation.  If it is not on a natural boundary it may not be loaded atomically, and
  the number and order of the load operations is unspecified.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area 
      from which to load the float.
<DT><B>Returns:</B><DD>The float from raw memory.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <code>SizeOutOfBoundsException</code> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>RawMemoryAccess.map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the float falls in an invalid address range.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="getFloats(long, float[], int, int)"><!-- --></A><H3>
getFloats</H3>
<PRE>
public void <B>getFloats</B>(long&nbsp;offset,
                      float[]&nbsp;floats,
                      int&nbsp;low,
                      int&nbsp;number)</PRE>
<DL>
<DD>Gets <code>number</code> floats starting at the given offset in the memory area
  associated with this object and assign 
 them to the int array passed starting at position <code>low</code>.
 <p>
  If the floats are aligned on natural boundaries
  each float is loaded from memory in a single atomic operation.  Groups of floats
  may be loaded together, but this is unspecified.
<p>
  If the floats are not aligned on natural boundaries they may not be loaded atomically and
  the number and order of load operations is unspecified.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
      at which to start loading.<DD><CODE>floats</CODE> - The array into which the floats loaded from the raw memory are placed.<DD><CODE>low</CODE> - The offset which is the starting point in the given array for the
            loaded items to be placed.<DD><CODE>number</CODE> - The number of floats to loaded.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <code>SizeOutOfBoundsException</code> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>RawMemoryAccess.map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if a float falls in an invalid address range.  This is checked at every
      entry in the array to allow for the possibility that the memory area
      could be unmapped or remapped.  The <code>floats</code> array could, therefore, be
      partially updated if the raw memory is unmapped or remapped mid-method.
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - Thrown if <code>low</code> is less than 0 or greater
                than <code>bytes.length - 1</code>, or if <code>low + number</code> is greater than or 
                equal to <code>bytes.length</code>.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="setDouble(long, double)"><!-- --></A><H3>
setDouble</H3>
<PRE>
public void <B>setDouble</B>(long&nbsp;offset,
                      double&nbsp;value)</PRE>
<DL>
<DD>Sets the <code>double</code> at the given offset in the memory area
  associated with this object.
  Even if it is aligned, the double value may not be updated atomically.  It is unspecified how many 
  load and store operations will be used or in what order.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
       at which to write the double.<DD><CODE>value</CODE> - The double to write.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <code>SizeOutOfBoundsException</code> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>RawMemoryAccess.map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the double falls in an invalid address range.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="setDoubles(long, double[], int, int)"><!-- --></A><H3>
setDoubles</H3>
<PRE>
public void <B>setDoubles</B>(long&nbsp;offset,
                       double[]&nbsp;doubles,
                       int&nbsp;low,
                       int&nbsp;number)</PRE>
<DL>
<DD>Sets <code>number</code> doubles starting at the given offset in the memory area
  associated with this object from the 
 double array passed starting at position <code>low</code>.
  Even if they are aligned, the double values may not be updated atomically.  It is unspecified how many 
  load and store operations will be used or in what order.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
       at which to start writing.<DD><CODE>doubles</CODE> - The array from which the items are obtained.<DD><CODE>low</CODE> - The offset which is the starting point in the given array for the
            items to be obtained.<DD><CODE>number</CODE> - The number of items to write.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <code>SizeOutOfBoundsException</code> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>RawMemoryAccess.map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the a short falls in an invalid address range.  This is checked at every
      entry in the array to allow for the possibility that the memory area
      could be unmapped or remapped.  The <code>doubles</code> array could, therefore, be
      partially updated if the raw memory is unmapped or remapped mid-method.
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - Thrown if <code>low</code> is less than 0 or greater
                than <code>bytes.length - 1</code>, or if <code>low + number</code> is greater than or 
                equal to <code>bytes.length</code>.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="setFloat(long, float)"><!-- --></A><H3>
setFloat</H3>
<PRE>
public void <B>setFloat</B>(long&nbsp;offset,
                     float&nbsp;value)</PRE>
<DL>
<DD>Sets the <code>float</code> at the given offset in the memory area
  associated with this object.
  On most processor architectures an aligned float can be stored in an atomic operation, but
  this is not required.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
       at which to write the integer.<DD><CODE>value</CODE> - The float to write.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <code>SizeOutOfBoundsException</code> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>RawMemoryAccess.map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the float falls in an invalid address range.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="setFloats(long, float[], int, int)"><!-- --></A><H3>
setFloats</H3>
<PRE>
public void <B>setFloats</B>(long&nbsp;offset,
                      float[]&nbsp;floats,
                      int&nbsp;low,
                      int&nbsp;number)</PRE>
<DL>
<DD>Sets <code>number</code> floats starting at the given offset in the memory area
  associated with this object from the 
 float array passed starting at position <code>low</code>.
  On most processor architectures each aligned float can be stored in an atomic operation, but
  this is not required.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
       at which to start writing.<DD><CODE>floats</CODE> - The array from which the items are obtained.<DD><CODE>low</CODE> - The offset which is the starting point in the given array for the
            items to be obtained.<DD><CODE>number</CODE> - The number of floats to write.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <code>SizeOutOfBoundsException</code> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>RawMemoryAccess.map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the float falls in an invalid address range.  This is checked at every
      entry in the array to allow for the possibility that the memory area
      could be unmapped or remapped.  The store of the array into memory could, therefore, be
      only partially  complete if the raw memory is unmapped or remapped mid-method.
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - Thrown if <code>low</code> is less than 0 or greater
                than <code>bytes.length - 1</code>, or if <code>low + number</code> is greater than or 
                equal to <code>bytes.length</code>.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<HR>

</BODY>
</HTML>

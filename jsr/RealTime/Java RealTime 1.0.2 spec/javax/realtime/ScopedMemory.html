<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_06) on Mon Jun 26 19:39:53 EDT 2006 -->
<TITLE>
ScopedMemory (Synchronization)
</TITLE>

<META NAME="keywords" CONTENT="javax.realtime.ScopedMemory class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="ScopedMemory (Synchronization)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.realtime</FONT>
<BR>
Class ScopedMemory</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><A HREF="../../javax/realtime/MemoryArea.html" title="class in javax.realtime">javax.realtime.MemoryArea</A>
      <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>javax.realtime.ScopedMemory</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../javax/realtime/LTMemory.html" title="class in javax.realtime">LTMemory</A>, <A HREF="../../javax/realtime/LTPhysicalMemory.html" title="class in javax.realtime">LTPhysicalMemory</A>, <A HREF="../../javax/realtime/VTMemory.html" title="class in javax.realtime">VTMemory</A>, <A HREF="../../javax/realtime/VTPhysicalMemory.html" title="class in javax.realtime">VTPhysicalMemory</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>ScopedMemory</B><DT>extends <A HREF="../../javax/realtime/MemoryArea.html" title="class in javax.realtime">MemoryArea</A></DL>
</PRE>

<P>
<code>ScopedMemory</code> is the abstract base class of all classes dealing with
 representations of memory spaces which have a limited lifetime.  In general, objects
 allocated in scoped memory are freed when (and only when) no schedulable object has
 access to the objects in the scoped memory. 
 <p>
 A <code>ScopedMemory</code> area is a connection to a particular region of
 memory and reflects the current status of that memory.  The object does not
 necessarily contain direct references to the region of memory.
 That is implementation dependent.
 <p> 
 When a <code>ScopedMemory</code> area is instantiated, the object itself is
 allocated from the current memory allocation context, but the
 memory space that object represents (it's backing store) is allocated from memory that is
 not otherwise directly visible to Java code; e.g., it might be allocated with the C <code>malloc</code>
 function.  This backing store behaves effectively as if it were allocated when the associated scoped
 memory object is constructed and freed at that scoped memory object's finalization. 
 <p> 
 The <A HREF="../../javax/realtime/ScopedMemory.html#enter()"><CODE>enter()</CODE></A> method of <code>ScopedMemory</code> is one
  mechanism used to make
 a memory area the current allocation context. 
 The other mechanism for activating a memory area is making it
  the initial memory area for a real-time thread or async event handler.
  Entry into the scope is accomplished, for example, by calling the
 method:
 <pre>
      <code>public void enter(Runnable logic)</code>
 </pre>
 where <code>logic</code> is a instance of <CODE>Runnable</CODE> whose <code>run()</code> method represents
 the entry point of the code that will run in the new scope. Exit
 from the scope occurs between the time the <code>runnable.run()</code> method completes and the time control
  returns from the <code>enter</code> method.
 By default, allocations of objects within <code>runnable.run()</code> are taken from 
  the backing store of the <code>ScopedMemory</code>.
 <p>
  <code>ScopedMemory</code> is an abstract class, but all specified methods include
  implementations.  The responsibilities of <code>MemoryArea, ScopedMemory</code> and the classes that
  extend <code>ScopedMemory</code> are not specified.  Application code should not extend <code>ScopedMemory</code>
  without detailed knowledge of its implementation.
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#ScopedMemory(long)">ScopedMemory</A></B>(long&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new <code>ScopedMemory</code> area with the given parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#ScopedMemory(long, java.lang.Runnable)">ScopedMemory</A></B>(long&nbsp;size,
             java.lang.Runnable&nbsp;logic)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new <code>ScopedMemory</code> area with the given parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#ScopedMemory(javax.realtime.SizeEstimator)">ScopedMemory</A></B>(<A HREF="../../javax/realtime/SizeEstimator.html" title="class in javax.realtime">SizeEstimator</A>&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new <code>ScopedMemory</code> area with the given parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#ScopedMemory(javax.realtime.SizeEstimator, java.lang.Runnable)">ScopedMemory</A></B>(<A HREF="../../javax/realtime/SizeEstimator.html" title="class in javax.realtime">SizeEstimator</A>&nbsp;size,
             java.lang.Runnable&nbsp;logic)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new <code>ScopedMemory</code> area with the given parameters.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#enter()">enter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Associate this memory area with the current 
 schedulable object for the duration of the execution of the 
 <code>run()</code> method of the instance of <code>Runnable</code>
 given in the constructor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#enter(java.lang.Runnable)">enter</A></B>(java.lang.Runnable&nbsp;logic)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Associate this memory area with the current 
 schedulable object for the duration of the execution of the 
 <code>run()</code> method of the given <code>Runnable</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#executeInArea(java.lang.Runnable)">executeInArea</A></B>(java.lang.Runnable&nbsp;logic)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Execute the run method from the <code>logic</code> parameter using this 
 memory area as the current allocation context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#getMaximumSize()">getMaximumSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the maximum size this memory area can attain.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#getPortal()">getPortal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a reference to the portal object in this instance of 
 <code>ScopedMemory</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#getReferenceCount()">getReferenceCount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the reference count of this <code>ScopedMemory</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#join()">join</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wait until the reference count of this <code>ScopedMemory</code> goes down to zero.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#join(javax.realtime.HighResolutionTime)">join</A></B>(<A HREF="../../javax/realtime/HighResolutionTime.html" title="class in javax.realtime">HighResolutionTime</A>&nbsp;time)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wait at most until the time designated by the <code>time</code> parameter for 
 the reference count of this <code>ScopedMemory</code> to drop to zero.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#joinAndEnter()">joinAndEnter</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In the error-free case, <code>joinAndEnter</code> combines 
 <code>join();enter();</code> such that no <code>enter()</code> from
 another schedulable object can intervene between the two method invocations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#joinAndEnter(javax.realtime.HighResolutionTime)">joinAndEnter</A></B>(<A HREF="../../javax/realtime/HighResolutionTime.html" title="class in javax.realtime">HighResolutionTime</A>&nbsp;time)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In the error-free case, <code>joinAndEnter</code> combines 
 <code>join();enter();</code> such that no <code>enter()</code> from
 another schedulable object can intervene between the two method invocations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#joinAndEnter(java.lang.Runnable)">joinAndEnter</A></B>(java.lang.Runnable&nbsp;logic)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In the error-free case, <code>joinAndEnter</code> combines 
 <code>join();enter();</code> such that no <code>enter()</code> from
 another schedulable object can intervene between the two method invocations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#joinAndEnter(java.lang.Runnable, javax.realtime.HighResolutionTime)">joinAndEnter</A></B>(java.lang.Runnable&nbsp;logic,
             <A HREF="../../javax/realtime/HighResolutionTime.html" title="class in javax.realtime">HighResolutionTime</A>&nbsp;time)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In the error-free case, <code>joinAndEnter</code> combines 
 <code>join();enter();</code> such that no <code>enter()</code> from
 another schedulable object can intervene between the two method invocations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#newArray(java.lang.Class, int)">newArray</A></B>(java.lang.Class&nbsp;type,
         int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocate an array of the given type in this memory area.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#newInstance(java.lang.Class)">newInstance</A></B>(java.lang.Class&nbsp;type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocate an object in this memory area.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#newInstance(java.lang.reflect.Constructor, java.lang.Object[])">newInstance</A></B>(java.lang.reflect.Constructor&nbsp;c,
            java.lang.Object[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocate an object in this memory area.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#setPortal(java.lang.Object)">setPortal</A></B>(java.lang.Object&nbsp;object)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <em>portal</em> object of the memory area represented by this instance of 
 <code>ScopedMemory</code> to the given object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/ScopedMemory.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a user-friendly representation of this <code>ScopedMemory</code> of the
  form <code>Scoped memory # &lt;num></code> where &lt;num> is a number that uniquely
  identifies this scoped memory area.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.realtime.MemoryArea"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class javax.realtime.<A HREF="../../javax/realtime/MemoryArea.html" title="class in javax.realtime">MemoryArea</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../javax/realtime/MemoryArea.html#getMemoryArea(java.lang.Object)">getMemoryArea</A>, <A HREF="../../javax/realtime/MemoryArea.html#memoryConsumed()">memoryConsumed</A>, <A HREF="../../javax/realtime/MemoryArea.html#memoryRemaining()">memoryRemaining</A>, <A HREF="../../javax/realtime/MemoryArea.html#size()">size</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ScopedMemory(long)"><!-- --></A><H3>
ScopedMemory</H3>
<PRE>
public <B>ScopedMemory</B>(long&nbsp;size)</PRE>
<DL>
<DD>Create a new <code>ScopedMemory</code> area with the given parameters.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>size</CODE> - The size of the new <code>ScopedMemory</code> area
             in bytes.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if <code>size</code> is less than
              zero.
<DD><CODE>java.lang.OutOfMemoryError</CODE> - Thrown if there is insufficient memory for the <code>ScopedMemory</code>
      object or for the backing memory.</DL>
</DL>
<HR>

<A NAME="ScopedMemory(long, java.lang.Runnable)"><!-- --></A><H3>
ScopedMemory</H3>
<PRE>
public <B>ScopedMemory</B>(long&nbsp;size,
                    java.lang.Runnable&nbsp;logic)</PRE>
<DL>
<DD>Create a new <code>ScopedMemory</code> area with the given parameters.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>size</CODE> - The size of the new <code>ScopedMemory</code> area
             in bytes.<DD><CODE>logic</CODE> - The <code>Runnable</code> to execute when this 
          <code>ScopedMemory</code> is entered.  If <code>logic</code>
          is null, this constructor is equivalent to constructing
          the memory area without a logic value.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if <code>size</code> is less than
              zero.
<DD><CODE><A HREF="../../javax/realtime/IllegalAssignmentError.html" title="class in javax.realtime">IllegalAssignmentError</A></CODE> - Thrown if storing <code>logic</code> in <code>this</code> would
                violate the assignment rules.
<DD><CODE>java.lang.OutOfMemoryError</CODE> - Thrown if there is insufficient memory for the <code>ScopedMemory</code>
      object or for the backing memory.</DL>
</DL>
<HR>

<A NAME="ScopedMemory(javax.realtime.SizeEstimator)"><!-- --></A><H3>
ScopedMemory</H3>
<PRE>
public <B>ScopedMemory</B>(<A HREF="../../javax/realtime/SizeEstimator.html" title="class in javax.realtime">SizeEstimator</A>&nbsp;size)</PRE>
<DL>
<DD>Create a new <code>ScopedMemory</code> area with the given parameters.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>size</CODE> - The size of the new <code>ScopedMemory</code> area
             estimated by an instance of <A HREF="../../javax/realtime/SizeEstimator.html" title="class in javax.realtime"><CODE>SizeEstimator</CODE></A>.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if <code>size</code> is null, 
              or <code>size.getEstimate()</code> is negative.
<DD><CODE>java.lang.OutOfMemoryError</CODE> - Thrown if there is insufficient memory for the <code>ScopedMemory</code>
      object or for the backing memory.</DL>
</DL>
<HR>

<A NAME="ScopedMemory(javax.realtime.SizeEstimator, java.lang.Runnable)"><!-- --></A><H3>
ScopedMemory</H3>
<PRE>
public <B>ScopedMemory</B>(<A HREF="../../javax/realtime/SizeEstimator.html" title="class in javax.realtime">SizeEstimator</A>&nbsp;size,
                    java.lang.Runnable&nbsp;logic)</PRE>
<DL>
<DD>Create a new <code>ScopedMemory</code> area with the given parameters.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>size</CODE> - The size of the new <code>ScopedMemory</code> area
             estimated by an instance of <A HREF="../../javax/realtime/SizeEstimator.html" title="class in javax.realtime"><CODE>SizeEstimator</CODE></A>.<DD><CODE>logic</CODE> - The logic which will use the memory represented by <code>this</code>
        as its initial memory area.    If <code>logic</code>
          is null, this constructor is equivalent to constructing
          the memory area without a logic value.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if <code>size</code> is null, 
              or <code>size.getEstimate()</code> is negative.
<DD><CODE>java.lang.OutOfMemoryError</CODE> - Thrown if there is insufficient memory for the <code>ScopedMemory</code>
      object or for the backing memory.
<DD><CODE><A HREF="../../javax/realtime/IllegalAssignmentError.html" title="class in javax.realtime">IllegalAssignmentError</A></CODE> - Thrown if storing <code>logic</code> in <code>this</code> would
                violate the assignment rules.</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="enter()"><!-- --></A><H3>
enter</H3>
<PRE>
public void <B>enter</B>()</PRE>
<DL>
<DD>Associate this memory area with the current 
 schedulable object for the duration of the execution of the 
 <code>run()</code> method of the instance of <code>Runnable</code>
 given in the constructor.
 During this period of execution, this memory area 
  becomes the default allocation context until another
  default allocation context is selected (using <code>enter</code>, 
  or <A HREF="../../javax/realtime/ScopedMemory.html#executeInArea(java.lang.Runnable)"><CODE>executeInArea(java.lang.Runnable)</CODE></A>) or 
  the <code>enter</code> method exits.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../javax/realtime/MemoryArea.html#enter()">enter</A></CODE> in class <CODE><A HREF="../../javax/realtime/MemoryArea.html" title="class in javax.realtime">MemoryArea</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/ScopedCycleException.html" title="class in javax.realtime">ScopedCycleException</A></CODE> - Thrown if this invocation would break the single
          parent rule.
<DD><CODE><A HREF="../../javax/realtime/ThrowBoundaryError.html" title="class in javax.realtime">ThrowBoundaryError</A></CODE> - Thrown when the JVM needs to propagate an exception allocated in <code>this</code> scope 
                to (or through) the memory area of the caller.  Storing a reference to that exception would cause
                an <A HREF="../../javax/realtime/IllegalAssignmentError.html" title="class in javax.realtime"><CODE>IllegalAssignmentError</CODE></A>, so the JVM cannot be permitted to deliver the exception. 
                The <A HREF="../../javax/realtime/ThrowBoundaryError.html" title="class in javax.realtime"><CODE>ThrowBoundaryError</CODE></A> is allocated in the current 
                allocation context and contains information about the exception it replaces.
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - Thrown if the caller is a Java thread, or if this 
      method is invoked during finalization of objects in scoped memory and entering 
      this scoped memory area would force deletion of the SO that triggered finalization.
      This would include the scope containing the SO, and the scope (if any) containing
      the scope containing the SO.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if the caller is a schedulable object and 
      no non-null value for <code>logic</code>
                was supplied when the memory area was constructed.
<DD><CODE><A HREF="../../javax/realtime/MemoryAccessError.html" title="class in javax.realtime">MemoryAccessError</A></CODE> - Thrown if caller is a no-heap schedulable object and this memory area's logic
      value is allocated in heap memory.</DL>
</DD>
</DL>
<HR>

<A NAME="enter(java.lang.Runnable)"><!-- --></A><H3>
enter</H3>
<PRE>
public void <B>enter</B>(java.lang.Runnable&nbsp;logic)</PRE>
<DL>
<DD>Associate this memory area with the current 
 schedulable object for the duration of the execution of the 
 <code>run()</code> method of the given <code>Runnable</code>.  
 During this period of execution, this memory area 
  becomes the default allocation context until another
  default allocation context is selected (using <code>enter</code>, 
  or <A HREF="../../javax/realtime/ScopedMemory.html#executeInArea(java.lang.Runnable)"><CODE>executeInArea(java.lang.Runnable)</CODE></A>) or 
  the <code>enter</code> method exits.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../javax/realtime/MemoryArea.html#enter(java.lang.Runnable)">enter</A></CODE> in class <CODE><A HREF="../../javax/realtime/MemoryArea.html" title="class in javax.realtime">MemoryArea</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>logic</CODE> - The Runnable object whose <code>run()</code> method 
              should be invoked.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/ScopedCycleException.html" title="class in javax.realtime">ScopedCycleException</A></CODE> - Thrown if this invocation would break the single
          parent rule.
<DD><CODE><A HREF="../../javax/realtime/ThrowBoundaryError.html" title="class in javax.realtime">ThrowBoundaryError</A></CODE> - Thrown when the JVM needs to propagate an exception allocated in <code>this</code> scope 
                to (or through) the memory area of the caller.  Storing a reference to that exception would cause
                an <A HREF="../../javax/realtime/IllegalAssignmentError.html" title="class in javax.realtime"><CODE>IllegalAssignmentError</CODE></A>, so the JVM cannot be permitted to deliver the exception. 
                The <A HREF="../../javax/realtime/ThrowBoundaryError.html" title="class in javax.realtime"><CODE>ThrowBoundaryError</CODE></A> is allocated in the current 
                allocation context and contains information about the exception it replaces.
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - Thrown if the caller is a Java thread, or if this 
      method is invoked during finalization of objects in scoped memory and entering 
      this scoped memory area would force deletion of the SO that triggered finalization.
      This would include the scope containing the SO, and the scope (if any) containing
      the scope containing the SO.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if the caller is a schedulable object and
      <code>logic</code> is null.</DL>
</DD>
</DL>
<HR>

<A NAME="executeInArea(java.lang.Runnable)"><!-- --></A><H3>
executeInArea</H3>
<PRE>
public void <B>executeInArea</B>(java.lang.Runnable&nbsp;logic)</PRE>
<DL>
<DD>Execute the run method from the <code>logic</code> parameter using this 
 memory area as the current allocation context. This method behaves as if it 
 moves the
 allocation context down the scope stack to the occurrence of <code>this</code>.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../javax/realtime/MemoryArea.html#executeInArea(java.lang.Runnable)">executeInArea</A></CODE> in class <CODE><A HREF="../../javax/realtime/MemoryArea.html" title="class in javax.realtime">MemoryArea</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>logic</CODE> - The runnable object whose <code>run()</code> method should 
 be executed.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - Thrown if the caller is a Java thread.
<DD><CODE><A HREF="../../javax/realtime/InaccessibleAreaException.html" title="class in javax.realtime">InaccessibleAreaException</A></CODE> - Thrown if the memory area is 
 not in the schedulable object's
 scope stack.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if the caller is a schedulable object and <code>logic</code> is null.</DL>
</DD>
</DL>
<HR>

<A NAME="getMaximumSize()"><!-- --></A><H3>
getMaximumSize</H3>
<PRE>
public long <B>getMaximumSize</B>()</PRE>
<DL>
<DD>Get the maximum size this memory area can attain. If this is
 a fixed size memory area, the returned value will be equal 
 to the initial size.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The maximum size attainable.</DL>
</DD>
</DL>
<HR>

<A NAME="getPortal()"><!-- --></A><H3>
getPortal</H3>
<PRE>
public java.lang.Object <B>getPortal</B>()</PRE>
<DL>
<DD>Return a reference to the portal object in this instance of 
 <code>ScopedMemory</code>.
 <p>
  Assignment rules are enforced on the value returned by <code>getPortal</code>
  as if the return value were first stored in an object allocated in the
  current allocation context, then moved to
  its final destination.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>A reference to the portal object or null if there is no portal object.
      The portal value is always set to null when the contents of the memory
      are deleted.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/IllegalAssignmentError.html" title="class in javax.realtime">IllegalAssignmentError</A></CODE> - Thrown if a reference to the portal object cannot
  be stored in the caller's allocation context; that is, if <code>this</code>
  is "inner" relative to the current allocation
   context or not on the caller's scope stack.
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - Thrown if the caller is a Java thread.</DL>
</DD>
</DL>
<HR>

<A NAME="getReferenceCount()"><!-- --></A><H3>
getReferenceCount</H3>
<PRE>
public int <B>getReferenceCount</B>()</PRE>
<DL>
<DD>Returns the reference count of this <code>ScopedMemory</code>. 
 <p>
 <strong>Note:</strong> A reference count of 0 reliably means that the scope is not referenced,
  but other reference counts are subject to artifacts of lazy/eager maintenance by the implementation.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The reference count of this <code>ScopedMemory</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="join()"><!-- --></A><H3>
join</H3>
<PRE>
public void <B>join</B>()
          throws java.lang.InterruptedException</PRE>
<DL>
<DD>Wait until the reference count of this <code>ScopedMemory</code> goes down to zero.
  Return immediately if the memory is unreferenced.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.InterruptedException</CODE> - If this schedulable object is interrupted by
       <A HREF="../../javax/realtime/RealtimeThread.html#interrupt()"><CODE>RealtimeThread.interrupt()</CODE></A> or 
      <A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#fire()"><CODE>AsynchronouslyInterruptedException.fire()</CODE></A>
      while waiting for the reference count to go to zero.
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - Thrown if the caller is a Java thread.</DL>
</DD>
</DL>
<HR>

<A NAME="join(javax.realtime.HighResolutionTime)"><!-- --></A><H3>
join</H3>
<PRE>
public void <B>join</B>(<A HREF="../../javax/realtime/HighResolutionTime.html" title="class in javax.realtime">HighResolutionTime</A>&nbsp;time)
          throws java.lang.InterruptedException</PRE>
<DL>
<DD>Wait at most until the time designated by the <code>time</code> parameter for 
 the reference count of this <code>ScopedMemory</code> to drop to zero.
  Return immediately if the memory area is unreferenced.
 <p>
        Since the
 time is expressed as a <A HREF="../../javax/realtime/HighResolutionTime.html" title="class in javax.realtime"><CODE>HighResolutionTime</CODE></A>, this method is an 
 accurate timer with nanosecond 
  granularity.  The actual
 resolution of the timer and even the quantity it measures
  depends on the clock associated with <code>time</code>. 
 The delay time may be relative or absolute. If relative, then the
 delay is the amount of time given by <code>time</code>, and 
  measured by its associated clock.
 If absolute, then the delay is until the indicated
 value is reached by the clock.  
 If the given absolute time is less than or equal to 
        the current value of the clock,
  the call to <code>join</code> returns immediately.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>time</CODE> - If this time is an absolute time, the wait is bounded by that point in time.
 If the time is a relative time (or a member of the <code>RationalTime</code>
 subclass of <code>RelativeTime</code>) the wait is bounded by a the specified
 interval from some time between the time <code>join</code> is called and the
 time it starts waiting for the reference count to reach zero.
<DT><B>Throws:</B>
<DD><CODE>java.lang.InterruptedException</CODE> - If this schedulable object is interrupted by
       <A HREF="../../javax/realtime/RealtimeThread.html#interrupt()"><CODE>RealtimeThread.interrupt()</CODE></A> or 
      <A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#fire()"><CODE>AsynchronouslyInterruptedException.fire()</CODE></A>
      while waiting for the reference count to go to zero.
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - Thrown if the caller is a Java thread.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if the caller is a schedulable object 
 and <code>time</code> is null.
<DD><CODE>java.lang.UnsupportedOperationException</CODE> - Thrown if the
 wait operation is not supported
 using the clock associated with <code>time</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="joinAndEnter()"><!-- --></A><H3>
joinAndEnter</H3>
<PRE>
public void <B>joinAndEnter</B>()
                  throws java.lang.InterruptedException</PRE>
<DL>
<DD>In the error-free case, <code>joinAndEnter</code> combines 
 <code>join();enter();</code> such that no <code>enter()</code> from
 another schedulable object can intervene between the two method invocations. 
 The resulting method
 will wait for the reference count on this <code>ScopedMemory</code> to reach zero,
 then enter the <code>ScopedMemory</code> and execute the <code>run</code> method from
 <code>logic</code> passed in the constructor. If no instance of <CODE>Runnable</CODE> 
 was passed to the memory area's constructor, 
 the method throws <code>IllegalArgumentException</code> immediately.
 <p>
 If multiple threads are waiting in <code>joinAndEnter</code> family
 methods for a memory area, at most <em>one</em> of them will be released each time
 the reference count goes to zero. 
 <p>
 Note that although <code>joinAndEnter</code> guarantees that the reference count is
 zero when the schedulable object is released for entry, it does not guarantee that the
 reference count will remain one for any length of time.  A subsequent <code>enter</code>
 could raise the reference count to two.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.InterruptedException</CODE> - If this schedulable object is interrupted by
       <A HREF="../../javax/realtime/RealtimeThread.html#interrupt()"><CODE>RealtimeThread.interrupt()</CODE></A> or 
      <A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#fire()"><CODE>AsynchronouslyInterruptedException.fire()</CODE></A>
      while waiting for the reference count to go to zero.
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - Thrown if the caller is a Java thread, or if this 
      method is invoked during finalization of objects in scoped memory and entering 
      this scoped memory area would force deletion of the SO that triggered finalization.
      This would include the scope containing the SO, and the scope (if any) containing
      the scope containing the SO.
<DD><CODE><A HREF="../../javax/realtime/ThrowBoundaryError.html" title="class in javax.realtime">ThrowBoundaryError</A></CODE> - Thrown when the JVM needs to propagate an exception allocated in <code>this</code> scope 
                to (or through) the memory area of the caller.  Storing a reference to that exception would cause
                an <A HREF="../../javax/realtime/IllegalAssignmentError.html" title="class in javax.realtime"><CODE>IllegalAssignmentError</CODE></A>, so the JVM cannot be permitted to deliver the exception. 
                The <A HREF="../../javax/realtime/ThrowBoundaryError.html" title="class in javax.realtime"><CODE>ThrowBoundaryError</CODE></A> is allocated in the current 
                allocation context and contains information about the exception it replaces.
<DD><CODE><A HREF="../../javax/realtime/ScopedCycleException.html" title="class in javax.realtime">ScopedCycleException</A></CODE> - Thrown if this invocation would break the single
          parent rule.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if the caller is a schedulable object and no non-null <code>logic</code> value
                was supplied to the memory area's constructor.
<DD><CODE><A HREF="../../javax/realtime/MemoryAccessError.html" title="class in javax.realtime">MemoryAccessError</A></CODE> - Thrown if caller is a non-heap schedulable object and this memory area's logic
      value is allocated in heap memory.</DL>
</DD>
</DL>
<HR>

<A NAME="joinAndEnter(javax.realtime.HighResolutionTime)"><!-- --></A><H3>
joinAndEnter</H3>
<PRE>
public void <B>joinAndEnter</B>(<A HREF="../../javax/realtime/HighResolutionTime.html" title="class in javax.realtime">HighResolutionTime</A>&nbsp;time)
                  throws java.lang.InterruptedException</PRE>
<DL>
<DD>In the error-free case, <code>joinAndEnter</code> combines 
 <code>join();enter();</code> such that no <code>enter()</code> from
 another schedulable object can intervene between the two method invocations.  The resulting method
 will wait for the reference count on this <code>ScopedMemory</code> to reach zero, or
 for the current time to reach the designated time,
 then enter the <code>ScopedMemory</code> and execute the <code>run</code> method from
 <code>Runnable</code> object passed to the constructor.  If no instance of <CODE>Runnable</CODE> 
 was passed to the memory area's constructor, the method 
 throws <code>IllegalArgumentException</code> immediately.
      * <p>
 If multiple threads are waiting in <code>joinAndEnter</code> family
 methods for a memory area, at most <em>one</em> of them will be released each time
 the reference count goes to zero. 
 <p>
        Since the
 time is expressed as a <A HREF="../../javax/realtime/HighResolutionTime.html" title="class in javax.realtime"><CODE>HighResolutionTime</CODE></A>, this method has an 
 accurate timer with nanosecond 
  granularity.  The actual
 resolution of the timer and even the quantity it measures
  depends on the clock associated with <code>time</code>. 
 The delay time may be relative or absolute. If relative, then the
 calling thread is blocked for at most the amount of time given by <code>time</code>, and 
  measured by its associated clock.
 If absolute, then the time delay is until the indicated
 value is reached by the clock.  
 If the given absolute time is less than or equal to 
        the current value of the clock,
  the call to <code>joinAndEnter</code> returns immediately.
 <p>
 Note that although <code>joinAndEnter</code> guarantees that the reference count is
 zero when the schedulable object is released for entry, it does not guarantee that the
 reference count will remain one for any length of time.  A subsequent <code>enter</code>
 could raise the reference count to two.
  <p>
  Note that expiration of <code>time</code> may cause control to enter the
  memory area before its reference count has gone to zero.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>time</CODE> - The time that bounds the wait.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/ThrowBoundaryError.html" title="class in javax.realtime">ThrowBoundaryError</A></CODE> - Thrown when the JVM needs to propagate an exception allocated in <code>this</code> scope 
                to (or through) the memory area of the caller.  Storing a reference to that exception would cause
                an <A HREF="../../javax/realtime/IllegalAssignmentError.html" title="class in javax.realtime"><CODE>IllegalAssignmentError</CODE></A>, so the JVM cannot be permitted to deliver the exception. 
                The <A HREF="../../javax/realtime/ThrowBoundaryError.html" title="class in javax.realtime"><CODE>ThrowBoundaryError</CODE></A> is allocated in the current 
                allocation context and contains information about the exception it replaces.
<DD><CODE>java.lang.InterruptedException</CODE> - If this schedulable object is interrupted by
       <A HREF="../../javax/realtime/RealtimeThread.html#interrupt()"><CODE>RealtimeThread.interrupt()</CODE></A> or 
      <A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#fire()"><CODE>AsynchronouslyInterruptedException.fire()</CODE></A>
      while waiting for the reference count to go to zero.
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - Thrown if the caller is a Java thread, or if this 
      method is invoked during finalization of objects in scoped memory and entering 
      this scoped memory area would force deletion of the SO that triggered finalization.
      This would include the scope containing the SO, and the scope (if any) containing
      the scope containing the SO.
<DD><CODE><A HREF="../../javax/realtime/ScopedCycleException.html" title="class in javax.realtime">ScopedCycleException</A></CODE> - Thrown if the caller is a schedulable object and this invocation would break the single
          parent rule.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if the caller is a schedulable object, and <code>time</code> is null or
        no non-null <code>logic</code> value
                was supplied to the memory area's constructor.
<DD><CODE>java.lang.UnsupportedOperationException</CODE> - Thrown if the
 wait operation is not supported
 using the clock associated with <code>time</code>.
<DD><CODE><A HREF="../../javax/realtime/MemoryAccessError.html" title="class in javax.realtime">MemoryAccessError</A></CODE> - Thrown if caller is a no-heap schedulable object and this memory area's logic
      value is allocated in heap memory.</DL>
</DD>
</DL>
<HR>

<A NAME="joinAndEnter(java.lang.Runnable)"><!-- --></A><H3>
joinAndEnter</H3>
<PRE>
public void <B>joinAndEnter</B>(java.lang.Runnable&nbsp;logic)
                  throws java.lang.InterruptedException</PRE>
<DL>
<DD>In the error-free case, <code>joinAndEnter</code> combines 
 <code>join();enter();</code> such that no <code>enter()</code> from
 another schedulable object can intervene between the two method invocations. The resulting method
 will wait for the reference count on this <code>ScopedMemory</code> to reach zero,
 then enter the <code>ScopedMemory</code> and execute the <code>run</code> method from
 <code>logic</code>
<p>
  If <code>logic</code> is null, throw <code>IllegalArgumentException</code> immediately.
 <p>
 If multiple threads are waiting in <code>joinAndEnter</code> family
 methods for a memory area, at most <em>one</em> of them will be released each time
 the reference count goes to zero. 
 <p>
 Note that although <code>joinAndEnter</code> guarantees that the reference count is
 zero when the schedulable object is released for entry, it does not guarantee that the
 reference count will remain one for any length of time.  A subsequent <code>enter</code>
 could raise the reference count to two.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>logic</CODE> - The <CODE>Runnable</CODE> object which contains the code to execute.
<DT><B>Throws:</B>
<DD><CODE>java.lang.InterruptedException</CODE> - If this schedulable object is interrupted by
       <A HREF="../../javax/realtime/RealtimeThread.html#interrupt()"><CODE>RealtimeThread.interrupt()</CODE></A> or 
      <A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#fire()"><CODE>AsynchronouslyInterruptedException.fire()</CODE></A>
      while waiting for the reference count to go to zero.
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - Thrown if the caller is a Java thread, or if this 
      method is invoked during finalization of objects in scoped memory and entering 
      this scoped memory area would force deletion of the SO that triggered finalization.
      This would include the scope containing the SO, and the scope (if any) containing
      the scope containing the SO.
<DD><CODE><A HREF="../../javax/realtime/ThrowBoundaryError.html" title="class in javax.realtime">ThrowBoundaryError</A></CODE> - Thrown when the JVM needs to propagate an exception allocated in <code>this</code> scope 
                to (or through) the memory area of the caller.  Storing a reference to that exception would cause
                an <A HREF="../../javax/realtime/IllegalAssignmentError.html" title="class in javax.realtime"><CODE>IllegalAssignmentError</CODE></A>, so the JVM cannot be permitted to deliver the exception. 
                The <A HREF="../../javax/realtime/ThrowBoundaryError.html" title="class in javax.realtime"><CODE>ThrowBoundaryError</CODE></A> is allocated in the current 
                allocation context and contains information about the exception it replaces.
<DD><CODE><A HREF="../../javax/realtime/ScopedCycleException.html" title="class in javax.realtime">ScopedCycleException</A></CODE> - Thrown if this invocation would break the single
          parent rule.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if the caller is a schedulable object and <code>logic</code> is null.</DL>
</DD>
</DL>
<HR>

<A NAME="joinAndEnter(java.lang.Runnable, javax.realtime.HighResolutionTime)"><!-- --></A><H3>
joinAndEnter</H3>
<PRE>
public void <B>joinAndEnter</B>(java.lang.Runnable&nbsp;logic,
                         <A HREF="../../javax/realtime/HighResolutionTime.html" title="class in javax.realtime">HighResolutionTime</A>&nbsp;time)
                  throws java.lang.InterruptedException</PRE>
<DL>
<DD>In the error-free case, <code>joinAndEnter</code> combines 
 <code>join();enter();</code> such that no <code>enter()</code> from
 another schedulable object can intervene between the two method invocations.  The resulting method
 will wait for the reference count on this <code>ScopedMemory</code> to reach zero, or
 for the current time to reach the designated time,
 then enter the <code>ScopedMemory</code> and execute the <code>run</code> method from
 <code>logic</code>.
 <p>
        Since the
 time is expressed as a <A HREF="../../javax/realtime/HighResolutionTime.html" title="class in javax.realtime"><CODE>HighResolutionTime</CODE></A>, this method is an 
 accurate timer with nanosecond 
  granularity.  The actual
 resolution of the timer and even the quantity it measures
  depends on the clock associated with <code>time</code>. 
 The delay time may be relative or absolute. If relative, then the
 delay is the amount of time given by <code>time</code>, and 
  measured by its associated clock.
 If absolute, then the delay is until the indicated
 value is reached by the clock.  
 If the given absolute time is less than or equal to 
        the current value of the clock,
  the call to <code>join</code> returns immediately.
<p>
        Throws <code>IllegalArgumentException</code> immediately if <code>logic</code> is null.
 <p>
 If multiple threads are waiting in <code>joinAndEnter</code> family
 methods for a memory area, at most <em>one</em> of them will be released each time
 the reference count goes to zero. 
 <p>
 Note that although <code>joinAndEnter</code> guarantees that the reference count is
 zero when the schedulable object is released for entry, it does not guarantee that the
 reference count will remain one for any length of time.  A subsequent <code>enter</code>
 could raise the reference count to two.
  <p>
  Note that expiration of <code>time</code> may cause control to enter the
  memory area before its reference count has gone to zero.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>logic</CODE> - The <CODE>Runnable</CODE> object which contains the code to execute.<DD><CODE>time</CODE> - The time that bounds the wait.
<DT><B>Throws:</B>
<DD><CODE>java.lang.InterruptedException</CODE> - If this schedulable object is interrupted by
       <A HREF="../../javax/realtime/RealtimeThread.html#interrupt()"><CODE>RealtimeThread.interrupt()</CODE></A> or 
      <A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#fire()"><CODE>AsynchronouslyInterruptedException.fire()</CODE></A>
      while waiting for the reference count to go to zero.
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - Thrown if the caller is a Java thread, or if this 
      method is invoked during finalization of objects in scoped memory and entering 
      this scoped memory area would force deletion of the SO that triggered finalization.
      This would include the scope containing the SO, and the scope (if any) containing
      the scope containing the SO.
<DD><CODE><A HREF="../../javax/realtime/ThrowBoundaryError.html" title="class in javax.realtime">ThrowBoundaryError</A></CODE> - Thrown when the JVM needs to propagate an exception allocated in <code>this</code> scope 
                to (or through) the memory area of the caller.  Storing a reference to that exception would cause
                an <A HREF="../../javax/realtime/IllegalAssignmentError.html" title="class in javax.realtime"><CODE>IllegalAssignmentError</CODE></A>, so the JVM cannot be permitted to deliver the exception. 
                The <A HREF="../../javax/realtime/ThrowBoundaryError.html" title="class in javax.realtime"><CODE>ThrowBoundaryError</CODE></A> is allocated in the current 
                allocation context and contains information about the exception it replaces.
<DD><CODE><A HREF="../../javax/realtime/ScopedCycleException.html" title="class in javax.realtime">ScopedCycleException</A></CODE> - Thrown if  the caller is a schedulable object and this invocation would break the single
          parent rule.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if the caller is a schedulable object and <code>time</code> or <code>logic</code> is null.
<DD><CODE>java.lang.UnsupportedOperationException</CODE> - Thrown if the wait operation is not supported
 using the clock associated with <code>time</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="newArray(java.lang.Class, int)"><!-- --></A><H3>
newArray</H3>
<PRE>
public java.lang.Object <B>newArray</B>(java.lang.Class&nbsp;type,
                                 int&nbsp;number)</PRE>
<DL>
<DD>Allocate an array of the given type in this memory area.
        This method may be concurrently used by multiple threads.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../javax/realtime/MemoryArea.html#newArray(java.lang.Class, int)">newArray</A></CODE> in class <CODE><A HREF="../../javax/realtime/MemoryArea.html" title="class in javax.realtime">MemoryArea</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - The class of the elements of the new array.  To create an array
        of a primitive type use a <code>type</code> such as <code>Integer.TYPE</code> (which
        would call for an array of the primitive int type.)<DD><CODE>number</CODE> - The number of elements in the new array.
<DT><B>Returns:</B><DD>A new array of class type, of number elements.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if <code>number</code>
  is less than zero, <code>type</code> is
  null, or <code>type</code> is <code>java.lang.Void.TYPE</code>.
<DD><CODE>java.lang.OutOfMemoryError</CODE> - Thrown if space in the memory area is exhausted.
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - Thrown if the caller is a Java thread.
<DD><CODE><A HREF="../../javax/realtime/InaccessibleAreaException.html" title="class in javax.realtime">InaccessibleAreaException</A></CODE> - Thrown if the memory area is not in the schedulable object's
 scope stack.</DL>
</DD>
</DL>
<HR>

<A NAME="newInstance(java.lang.Class)"><!-- --></A><H3>
newInstance</H3>
<PRE>
public java.lang.Object <B>newInstance</B>(java.lang.Class&nbsp;type)
                             throws java.lang.IllegalAccessException,
                                    java.lang.InstantiationException</PRE>
<DL>
<DD>Allocate an object in this memory area.
        This method may be concurrently used by multiple threads.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../javax/realtime/MemoryArea.html#newInstance(java.lang.Class)">newInstance</A></CODE> in class <CODE><A HREF="../../javax/realtime/MemoryArea.html" title="class in javax.realtime">MemoryArea</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - The class of which to create a new instance.
<DT><B>Returns:</B><DD>A new instance of class <code>type</code>.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalAccessException</CODE> - The class or initializer is inaccessible.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if <code>type</code> is
  null.
<DD><CODE>java.lang.ExceptionInInitializerError</CODE> - Thrown if an unexpected exception has occurred in a static initializer
<DD><CODE>java.lang.OutOfMemoryError</CODE> - Thrown if space in the memory area is exhausted.
<DD><CODE>java.lang.InstantiationException</CODE> - Thrown if the specified class object could not be
         instantiated. Possible causes are: it is an interface, it is abstract,
         it is an array, or an exception was thrown by the constructor.
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - Thrown if the caller is a Java thread.
<DD><CODE><A HREF="../../javax/realtime/InaccessibleAreaException.html" title="class in javax.realtime">InaccessibleAreaException</A></CODE> - Thrown if the memory area is not in the schedulable object's
 scope stack.</DL>
</DD>
</DL>
<HR>

<A NAME="newInstance(java.lang.reflect.Constructor, java.lang.Object[])"><!-- --></A><H3>
newInstance</H3>
<PRE>
public java.lang.Object <B>newInstance</B>(java.lang.reflect.Constructor&nbsp;c,
                                    java.lang.Object[]&nbsp;args)
                             throws java.lang.IllegalAccessException,
                                    java.lang.InstantiationException,
                                    java.lang.reflect.InvocationTargetException</PRE>
<DL>
<DD>Allocate an object in this memory area.
        This method may be concurrently used by multiple threads.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../javax/realtime/MemoryArea.html#newInstance(java.lang.reflect.Constructor, java.lang.Object[])">newInstance</A></CODE> in class <CODE><A HREF="../../javax/realtime/MemoryArea.html" title="class in javax.realtime">MemoryArea</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c</CODE> - TThe constructor for the new instance.<DD><CODE>args</CODE> - An array of arguments to pass to the constructor.
<DT><B>Returns:</B><DD>A new instance of the object constructed by <code>c</code>.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalAccessException</CODE> - Thrown if the class or initializer is inaccessible under Java access control.
<DD><CODE>java.lang.InstantiationException</CODE> - Thrown if the specified class object could not be
         instantiated. Possible causes are: it is an interface, it is abstract,
         it is an array.
<DD><CODE>java.lang.OutOfMemoryError</CODE> - Thrown if space in the memory area is exhausted.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if <code>c</code> is
        null, or the <code>args</code>
        array does not contain the number of arguments required by <code>c</code>.  A null
                value of <code>args</code> is treated like an array of length 0.
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - Thrown if the caller is a Java thread.
<DD><CODE>java.lang.reflect.InvocationTargetException</CODE> - Thrown if the underlying constructor throws an exception.
<DD><CODE><A HREF="../../javax/realtime/InaccessibleAreaException.html" title="class in javax.realtime">InaccessibleAreaException</A></CODE> - Thrown if the memory area is not in the schedulable object's
 scope stack.</DL>
</DD>
</DL>
<HR>

<A NAME="setPortal(java.lang.Object)"><!-- --></A><H3>
setPortal</H3>
<PRE>
public void <B>setPortal</B>(java.lang.Object&nbsp;object)</PRE>
<DL>
<DD>Sets the <em>portal</em> object of the memory area represented by this instance of 
 <code>ScopedMemory</code> to the given object.  The object must have  been
 allocated in this <code>ScopedMemory</code> instance.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>object</CODE> - The object which will become the portal for this.
        If null the previous portal object remains the 
        portal object for this or if there was no previous 
        portal object then there is still no portal object 
        for <code>this</code>.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - Thrown if the caller is a Java Thread, and 
   <code>object</code> is not null.
<DD><CODE><A HREF="../../javax/realtime/IllegalAssignmentError.html" title="class in javax.realtime">IllegalAssignmentError</A></CODE> - Thrown if the caller is a schedulable object, and 
   <code>object</code> is not allocated in this scoped memory instance and
   not null.
<DD><CODE><A HREF="../../javax/realtime/InaccessibleAreaException.html" title="class in javax.realtime">InaccessibleAreaException</A></CODE> - Thrown if the caller is a schedulable object, 
      <code>this</code> memory area is 
    not in the caller's
    scope stack and <code>object</code> is not null.</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Returns a user-friendly representation of this <code>ScopedMemory</code> of the
  form <code>Scoped memory # &lt;num></code> where &lt;num> is a number that uniquely
  identifies this scoped memory area.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The string representation</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<HR>

</BODY>
</HTML>

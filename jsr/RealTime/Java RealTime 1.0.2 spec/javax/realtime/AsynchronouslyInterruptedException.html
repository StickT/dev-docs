<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_06) on Mon Jun 26 19:39:51 EDT 2006 -->
<TITLE>
AsynchronouslyInterruptedException (Synchronization)
</TITLE>

<META NAME="keywords" CONTENT="javax.realtime.AsynchronouslyInterruptedException class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="AsynchronouslyInterruptedException (Synchronization)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.realtime</FONT>
<BR>
Class AsynchronouslyInterruptedException</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by ">java.lang.Throwable
      <IMG SRC="../../resources/inherit.gif" ALT="extended by ">java.lang.Exception
          <IMG SRC="../../resources/inherit.gif" ALT="extended by ">java.lang.InterruptedException
              <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>javax.realtime.AsynchronouslyInterruptedException</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.io.Serializable</DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../javax/realtime/Timed.html" title="class in javax.realtime">Timed</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>AsynchronouslyInterruptedException</B><DT>extends java.lang.InterruptedException</DL>
</PRE>

<P>
A special exception that is thrown in response to an attempt to asynchronously
 transfer the locus of control of a schedulable object.
 <p>
 A schedulable object that is executing a method or constructor,
 which is declared with an <A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html" title="class in javax.realtime"><CODE>AsynchronouslyInterruptedException</CODE></A> 
 in its <code>throws</code> clause, can be asynchronously interrupted except
 when it is executing in the lexical scope of a synchronized statement within that method/constructor. 
 As soon as the schedulable object leaves the lexical scope of the method by calling
 another method/constructor it may be asynchronously interrupted if the called method/constructor
 is asynchronously interruptible. (See this chapter's introduction section for the detailed semantics).

 <p> 
 The asynchronous interrupt is generated for a real-time thread, <code>t</code>, when
 the <code>t.interrupt()</code> method is called or 
 the <code>fire</code> method is called of an AIE for which t has a 
 <code>doInterruptible</code> method call in progress.
 <p>
 The interrupt is generated for an AEH (or BAEH), <code>h</code>, if  
 the <code>fire</code> method is called of an AIE for which <code>h</code> has a 
 <code>doInterruptible</code> method call in progress.
 <p>
 If an asynchronous interrupt is generated when the target real-time 
 thread/schedulable object is executing within an ATC-deferred section, the
 asynchronous interrupt becomes pending. A pending asynchronous interrupt
 is delivered when the target real-time thread/schedulable object next attempts
 to enter asynchronously interruptible code.

 <p> 
 Asynchronous transfers of control (ATCs) are intended to allow long-running
 computations to be terminated without the overhead or
 latency of polling with <CODE>Thread.interrupted()</CODE>. 
  
 <p>
 When <A HREF="../../javax/realtime/RealtimeThread.html#interrupt()"><CODE>RealtimeThread.interrupt()</CODE></A>, or <code>AsynchronouslyInterruptedException.fire()</code> is called,
 the <code>AsynchronouslyInterruptedException</code> is compared against any currently
 pending <code>AsynchronouslyInterruptedException</code> on the schedulable object. If 
 there is none, or if the depth of the <code>AsynchronouslyInterruptedException</code>
 is less than the currently pending <code>AsynchronouslyInterruptedException</code>;
 (i.e., it is targeted at a less deeply nested method call), the new 
 <code>AsynchronouslyInterruptedException</code> becomes the currently
 pending <code>AsynchronouslyInterruptedException</code> and the previously pending 
 <code>AsynchronouslyInterruptedException</code> is discarded.  
 Otherwise, the new <code>AsynchronouslyInterruptedException</code> is discarded.
  
 <p>
 When an <code>AsynchronouslyInterruptedException</code> is caught, the catch clause 
 may invoke the 
 <code>clear()</code> method on the <code>AsynchronouslyInterruptedException</code>
 in which it is interested to see if the exception matches the pending
 <code>AsynchronouslyInterruptedException</code>.
 If so, the pending <code>AsynchronouslyInterruptedException</code> is cleared
 for the schedulable object and <code>clear</code> returns true.
 Otherwise, the current AIE remains pending and <code>clear</code> returns false.
 
 <p>
 <code>RealtimeThread.interrupt()</code> generates a system-wide
 generic <code>AsynchronouslyInterruptedException</code> which will always propagate
 outward through interruptible methods until the 
 generic <code>AsynchronouslyInterruptedException</code> is identified and handled.
 The pending state of the generic AIE is per-schedulable object.
 <p>
 Other sources (e.g., <code>AsynchronouslyInterruptedException.fire()</code> and <A HREF="../../javax/realtime/Timed.html" title="class in javax.realtime"><CODE>Timed</CODE></A>) will generate 
 specific instances of <code>AsynchronouslyInterruptedException</code> which 
 applications can identify and thus limit propagation.

 <p>
 <A HREF="../../javax/realtime/AsyncEventHandler.html" title="class in javax.realtime"><CODE>AsyncEventHandler</CODE></A> objects should interact with the ATC mechanisms
 via the <A HREF="../../javax/realtime/Interruptible.html" title="interface in javax.realtime"><CODE>Interruptible</CODE></A> interface.
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../serialized-form.html#javax.realtime.AsynchronouslyInterruptedException">Serialized Form</A></DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#AsynchronouslyInterruptedException()">AsynchronouslyInterruptedException</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an instance of <code>AsynchronouslyInterruptedException</code>.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#clear()">clear</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomically see if <code>this</code> 
 is pending on the currently executing schedulable object,
 and if so, make it non-pending.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#disable()">disable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disable the throwing of this exception.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#doInterruptible(javax.realtime.Interruptible)">doInterruptible</A></B>(<A HREF="../../javax/realtime/Interruptible.html" title="interface in javax.realtime">Interruptible</A>&nbsp;logic)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executes the <code>run()</code> method of the given <A HREF="../../javax/realtime/Interruptible.html" title="interface in javax.realtime"><CODE>Interruptible</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#enable()">enable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable the throwing of this exception.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#fire()">fire</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate this exception if its <code>doInterruptible()</code> has been invoked 
 and not completed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html" title="class in javax.realtime">AsynchronouslyInterruptedException</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#getGeneric()">getGeneric</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the singleton system generic <code>AsynchronouslyInterruptedException</code>
 that is generated when <A HREF="../../javax/realtime/RealtimeThread.html#interrupt()"><CODE>RealtimeThread.interrupt()</CODE></A>is invoked.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#happened(boolean)">happened</A></B>(boolean&nbsp;propagate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Since 1.0.1. This method seriously violates standard Java exception
 semantics, and while it is a convenience it is not required.
 The <code>happened</code> method can be replaced with the <code>clear</code>
 method and application logic.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#isEnabled()">isEnabled</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Query the enabled status of this exception.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#propagate()">propagate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Since 1.0.1. This method seriously violates standard Java exception
 semantics, and while it is a convenience it is not required. It should be replaced
 with <code>throw</code> of an instance of <code>AsynchronouslyInterruptedException</code>.</I></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Throwable"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Throwable</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>fillInStackTrace, getCause, getLocalizedMessage, getMessage, getStackTrace, initCause, printStackTrace, printStackTrace, printStackTrace, setStackTrace, toString</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="AsynchronouslyInterruptedException()"><!-- --></A><H3>
AsynchronouslyInterruptedException</H3>
<PRE>
public <B>AsynchronouslyInterruptedException</B>()</PRE>
<DL>
<DD>Create an instance of <code>AsynchronouslyInterruptedException</code>.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getGeneric()"><!-- --></A><H3>
getGeneric</H3>
<PRE>
public static <A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html" title="class in javax.realtime">AsynchronouslyInterruptedException</A> <B>getGeneric</B>()</PRE>
<DL>
<DD>Gets the singleton system generic <code>AsynchronouslyInterruptedException</code>
 that is generated when <A HREF="../../javax/realtime/RealtimeThread.html#interrupt()"><CODE>RealtimeThread.interrupt()</CODE></A>is invoked.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The generic <code>AsynchronouslyInterruptedException</code>.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - if the current thread is a Java thread.</DL>
</DD>
</DL>
<HR>

<A NAME="enable()"><!-- --></A><H3>
enable</H3>
<PRE>
public boolean <B>enable</B>()</PRE>
<DL>
<DD>Enable the throwing of this exception.  This method is valid only when the caller
 has a call to <code>doInterruptible()</code> in progress.  If invoked when no
 call to <code>doInterruptible()</code> is in progress, <code>enable</code>
 returns false and does nothing.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>True if <code>this</code> was disabled before the method was called and
        the call was invoked whilst the associated <code>doInterruptible()</code>
        is in progress.
        False: otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="disable()"><!-- --></A><H3>
disable</H3>
<PRE>
public boolean <B>disable</B>()</PRE>
<DL>
<DD>Disable the throwing of this exception. If the <code>fire</code> method is called
 on <code>this</code> AIE whilst it is disabled, the fire is held pending and delivered
 as soon as the AIE is enabled and the interruptible code is within an AI-method. 
 If an AIE is pending when the associated disable method is called, the AIE
 remains pending, and is delivered as soon as the AIE is enabled and 
 the interruptible code is within an AI-method. 
 <p> 
 This method is valid only when the caller
 has a call to <code>doInterruptible()</code> in progress.  If invoked when no
 call to <code>doInterruptible()</code> is in progress, <code>disable</code>
 returns false and does nothing.
 <p> 
 Note: disabling the genericAIE associated with a real-time thread only affects 
 the firing of that AIE. If the genericAIE is generated by the 
 <A HREF="../../javax/realtime/RealtimeThread.html#interrupt()"><CODE>RealtimeThread.interrupt()</CODE></A> mechanism, the AIE is delivered (unless the
 <code>Interruptible</code> code is in an AI-deferred region, in which case 
 it is marked as pending and handled in the usual way).
<P>
<DD><DL>

<DT><B>Returns:</B><DD>True if <code>this</code> was enabled before the method was called and
        the call was invoked with the associated <code>doInterruptible()</code>
        in progress.
        False: otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="isEnabled()"><!-- --></A><H3>
isEnabled</H3>
<PRE>
public boolean <B>isEnabled</B>()</PRE>
<DL>
<DD>Query the enabled status of this exception. 
 <p>
 This method is valid only when the caller
 has a call to <code>doInterruptible()</code> in progress.  If invoked when no
 call to <code>doInterruptible()</code> is in progress, <code>enable</code>
 returns false and does nothing.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>True if this is enabled and the method call was invoked
        in the context of the associated <code>doInterruptible()</code>.
         False otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="fire()"><!-- --></A><H3>
fire</H3>
<PRE>
public boolean <B>fire</B>()</PRE>
<DL>
<DD>Generate this exception if its <code>doInterruptible()</code> has been invoked 
 and not completed.

 If <code>this</code> is the only outstanding AIE on the schedulable 
 object that invoked this AIE's 
 <A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#doInterruptible(javax.realtime.Interruptible)"><CODE>doInterruptible(Interruptible)</CODE></A> method, this AIE becomes that 
 schedulable object's current AIE. Otherwise, it only becomes the current 
 AIE if it is at a less deeper level of nesting compared with the current 
 outstanding AIE.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>True if <code>this</code> is not disabled and it has an invocation
         of a <code>doInterruptible()</code> in progress and there is no
         outstanding fire request.
         False otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="doInterruptible(javax.realtime.Interruptible)"><!-- --></A><H3>
doInterruptible</H3>
<PRE>
public boolean <B>doInterruptible</B>(<A HREF="../../javax/realtime/Interruptible.html" title="interface in javax.realtime">Interruptible</A>&nbsp;logic)</PRE>
<DL>
<DD>Executes the <code>run()</code> method of the given <A HREF="../../javax/realtime/Interruptible.html" title="interface in javax.realtime"><CODE>Interruptible</CODE></A>.
 This method may be on the stack in exactly one <A HREF="../../javax/realtime/Schedulable.html" title="interface in javax.realtime"><CODE>Schedulable</CODE></A> object.
 An attempt to invoke this method in a schedulable object while it is on the
 stack of another or the same schedulable object will cause an
 immediate return with a value of false.
 <p>
 The <code>run</code> method of given <code>Interruptible</code> is always entered 
 with the exception in the enabled state, but that state can be modified with
 <A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#enable()"><CODE>enable()</CODE></A> and <A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#disable()"><CODE>disable()</CODE></A> and the state can be 
 observed with <A HREF="../../javax/realtime/AsynchronouslyInterruptedException.html#isEnabled()"><CODE>isEnabled()</CODE></A>.
 <p>
 The <code>interruptAction</code> method of the given <A HREF="../../javax/realtime/Interruptible.html" title="interface in javax.realtime"><CODE>Interruptible</CODE></A> is called 
 if any AIE is generated for the schedulable object executing the <code>doInterruptible</code>
 method. The generated AIE remains pending after the <code>interruptAction</code> method
 has finished if the pending AIE is not the AIE executing the <code>doInterruptible</code>
 method. If it is, the pending AIE is cleared.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>logic</CODE> - An instance of an <A HREF="../../javax/realtime/Interruptible.html" title="interface in javax.realtime"><CODE>Interruptible</CODE></A> whose <code>run()</code> 
 method will be called.
<DT><B>Returns:</B><DD>True if the method call completed normally. 
         False if another call to <code>doInterruptible</code> has not completed.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - Thrown if called from a Java thread.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if a null parameter was passed.</DL>
</DD>
</DL>
<HR>

<A NAME="happened(boolean)"><!-- --></A><H3>
happened</H3>
<PRE>
public boolean <B>happened</B>(boolean&nbsp;propagate)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Since 1.0.1. This method seriously violates standard Java exception
 semantics, and while it is a convenience it is not required.
 The <code>happened</code> method can be replaced with the <code>clear</code>
 method and application logic.</I>
<P>
<DD>Used with an instance of this exception to see if the current exception
 is this exception. 
 
 When an <code>AsynchronouslyInterruptedException</code> is caught, the catch clause 
 may invoke the 
 <code>happened()</code> method on the <code>AsynchronouslyInterruptedException</code>
 in which it is interested to see if it matches the pending
 <code>AsynchronouslyInterruptedException</code>.
 If so, the pending <code>AsynchronouslyInterruptedException</code> is cleared
 for the schedulable object and <code>happened</code> returns true.
 Otherwise, the behavior of happened depends on its 
 <code>propagation</code> parameter. If <code>propagation</code> parameter is true, 
 the <code>AsynchronouslyInterruptedException</code> will continue to propagate
 outward; i.e., it will be re-thrown by a mechanism that bypassed the normal
 requirement that the checked exception be identified in the method's signature.
  If <code>propagation</code> parameter is false, <code>happened</code>
 will return false and the <code>AsynchronouslyInterruptedException</code>
 remains pending.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>propagate</CODE> - Control the behavior when <code>this</code> is not the
 current exception:
 <ul>
 <li>If true and this exception is the current one, set the state of this to non 
 pending and return true.</li>
<li>
 If true and this exception is not the current one, propagate the exception; i.e.,
 rethrow it.
 </li><li>
 If false and this exception is the current one, the state of this is set
 to nonpending (i.e., it will stop propagating) and return true. 
 </li><li>
 If false and this exception is not the current one, return false.</li>
 </ul>
<DT><B>Returns:</B><DD>True if this is the current exception.  
         False if this is not the current exception.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - Thrown if called from a Java thread.</DL>
</DD>
</DL>
<HR>

<A NAME="propagate()"><!-- --></A><H3>
propagate</H3>
<PRE>
public static void <B>propagate</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Since 1.0.1. This method seriously violates standard Java exception
 semantics, and while it is a convenience it is not required. It should be replaced
 with <code>throw</code> of an instance of <code>AsynchronouslyInterruptedException</code>.</I>
<P>
<DD>Cause the pending exception to continue up the stack.
 The current AIE remains pending and control is transferred immediately
 to the next suitable catch or finally clause under the normal rules for 
 AIE propagation.
 <p>
 If there is no current AIE, the method does nothing and simply returns.
 <p>
 This method is normally used in a catch clause that is handling an AIE, but
 that is not required. The method may be invoked at any time (from a schedulable
 object).
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - Thrown if called from a Java thread.</DL>
</DD>
</DL>
<HR>

<A NAME="clear()"><!-- --></A><H3>
clear</H3>
<PRE>
public boolean <B>clear</B>()</PRE>
<DL>
<DD>Atomically see if <code>this</code> 
 is pending on the currently executing schedulable object,
 and if so, make it non-pending.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>True if <code>this</code> was pending.  
         False if <code>this</code> was not pending.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalThreadStateException</CODE> - Thrown if called from a Java thread.<DT><B>Since:</B></DT>
  <DD>1.0.1</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<HR>

</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_06) on Mon Jun 26 19:39:49 EDT 2006 -->
<TITLE>
Overview (Clocks and Timers)
</TITLE>

<META NAME="keywords" CONTENT="Overview">

<LINK REL ="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Overview (Clocks and Timers)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">

<HR>
Clocks and Timers
                This section describes the RTSJ clocks and timers.
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#overview_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Packages</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="javax/realtime/package-summary.html">javax.realtime</A></B></TD>
<TD>&nbsp;</TD>
</TR>
</TABLE>

<P>
&nbsp;<A NAME="overview_description"><!-- --></A>
<P>
<h1>Clocks and Timers</h1>
                <p>This section describes the RTSJ clocks and timers.  These classes:</p>
                <ul>
                        <li>Allow creation of a timer whose expiration is either periodic or set to occur at a particular time as kept by a system-dependent time base (clock).
                        <li>Trigger some behavior to occur on expiration of a timer, using the asynchronous event mechanisms provided by the specification.
                </ul>
                <h2>Definitions</h2>
                The following terms and abbreviations will be used:
                <P>
                A <i>timing mechanism</i>  is either a Clock or a Timer, capable of representing and following the progress of time, by means of time values. </P>
                <P>
                A <i>monotonic clock</i>  is a clock whose time values are monotonic, and a <i>monotonic non-decreasing</i> clock is a clock whose time values are monotonic non-decreasing. Monotonicity is a boolean property, while time synchronization, uniformity and accuracy are characteristics that depend on agreed tolerances. </P>
                <P>
                <i>Time synchronization</i>  is a relation between two clocks. Two clocks are synchronized when the difference between their time values is less than some specified offset. Synchronization in general degrades with time, and may be lost, given a specified offset. </P>
                <P>
                <i>Resolution</i>  is the minimal time value interval that can be distinguished by a timing mechanism. </P>
                <P>
                <i>Uniformity</i>,  in this context, refers to the measurement of the progress of time at a consistent rate, with a tolerance on the variability. Uniformity is affected by two other factors, <i>jitter</i> and <i>stability</i>. </P>
                <P>
                <i>Jitter</i> is a short-term and non-cumulative small variation caused by noise sources, like thermal noise. More practically, jitter refers to the distribution of the differences between when events are actually fired or noticed by the software and when they should have really occurred according to time in the real-world. </P>
                <P>
                (Lack-of) <i>stability</i> accounts for large and often cumulative variations, due to e.g. supply voltage and temperature. </P>
                <P>
                In practice a timing mechanism is driven by an oscillator. <i>Accuracy</i>  is the difference between the desired frequency and the actual frequency of the oscillator, and a major reason of synchronization loss. </P>
                <P>
                The system <i>real-time clock</i>  is monotonic non-decreasing, with the epoch as the Epoch (January 1, 1970, 00:00:00 GMT). The system real-time clock is not necessarily synchronized with the external world, and the correctness of the epoch as a time base depends on such synchronization. It is as uniform and accurate as allowed by the underlying hardware. </P>
                <P>
                A <code>Timer</code> measures time using a given Clock, and fires an event as scheduled. </P>
                <P>
                In the context of a <code>Timer</code>,  <i>firing</i>  is the action that causes the release of any associated <code>AsyncEventHandler</code>, while the  <i>skipping</i>  of firing is an action with no consequences. </P>
                <P>
                A <code>Timer</code> is <i>active</i> if it has been started and not stopped since last started and it has a time in the future at which it is expected to fire or skip, else it is  <i>not-active</i>.</P>
                <P>
                In the context of a <code>Timer</code>, <i>enabling</i> allows firing, while  <i>disabling</i> causes the skipping of firing. Enabling and disabling act as a mask over firing. </P>
                <P>
                The behavior of a <code>OneShotTimer</code> is that of a <code>Timer</code> that does not automatically reschedule its firing after an initial firing, or after the skipping of an initial firing (if <i>disabled</i> and <i>active</i> when the firing was due). It is specified using an initial firing time. </P>
                <P>
                The behavior of a <code>PeriodicTimer</code> is that of a <code>Timer</code> that automatically reschedules its firing after an initial firing, or after the skipping of an initial firing if disabled when the firing was due. It is specified using an initial firing time and an interval or period used for the self-rescheduling. </P>
                <P>
                Every timer has at least one clock associated with it, on which the measurement of time will be based. The <code>OneShotTimer</code> timer has one, the clock associated with the specification of the initial firing time. The <code>PeriodicTimer</code> timer has two, the clock associated with the specification of the initial firing time and the clock associated with the specification of the interval or period.</P>
                For both timers it is possible to provide an explicit clock to override the clock associated with parameters. See the individual classes for details. <P>
                </P>
The <i>counting time</i> is the time accumulated while <i>active</i>
by a <code>Timer</code> created or rescheduled using
a <code>RelativeTime</code> to specify the initial firing/skipping time.
The <i>counting time</i> is zeroed at the beginning of an activation,
or when rescheduled, while <i>active</i>, before the initial
firing/skipping of an activation.

                <h2>Overview</h2>
                <p>The classes provided by this section are <code>Clock</code>, <code>Timer</code>, <code>PeriodicTimer</code>, <code>and OneShotTimer</code>.</p>
                <p>At least one instance of the abstract<code> Clock</code> class is provided by the implementation, the system <em>real-time clock</em>, and this instance is made available as a singleton. </p>
                <p><code>Timer</code> is an abstract class and consequently only its subclasses can be instantiated. The <code>Timer</code> class provides the interface and underlying implementation for both one-shot and periodic timers.</p>
                <p>Instances of <code>OneShotTimer</code> and <code>PeriodicTimer</code> can be created and rescheduled specifying the initial firing time either as an <code>AbsoluteTime</code>, to be considered at the application of the start command, or as a <code>RelativeTime</code>, to be considered from the application of the start command.</p>
                <p>The period for a <code>PeriodicTimer</code> is always specified as a <code>RelativeTime</code>.</p>
                <p>An instance of <code>OneShotTimer</code> describes an event that is to be triggered at most once (unless restarted after expiration). It may be used as the source for time-outs.</p>
                <p>An instance of <code>PeriodicTimer</code> fires or skips on a periodic schedule.</p>
                <h2>Semantics and Requirements</h2>
                <p>This list establishes the semantics and requirements that are applicable across the classes of this section. Semantics that apply to particular classes, constructors, methods, and fields will be found in the class description and the constructor, method, and field detail sections.</p>
                <ol>
                <li> Clocks and Timers relation:
                <ol type="a">
                        <li>The relation between clocks and timers described below is better understood if a clock is seen 
                        as providing an interrupt at intervals based on its resolution. 
                        </li>
                        <li>Timers can be modeled as counters, or as comparators.
                        </li>
                                        <ol type="i">
                                                <li>Timer modeled as counter:  The timer is viewed as if every clock interrupt increments a count up to the firing count, initially given by either an instance of <code>RelativeTime</code> or computed as the difference between an instance of <code>AbsoluteTime</code> and a semantically specified &quot;now&quot; (using the same clock).
                                                    <ul>
                                                    <li>
                                                        In this model, <code>start</code> is understood as defining &quot;now&quot; and start counting, <code>stop</code> is understood as stop counting. <code>start</code> after <code>stop</code> may be understood as start counting again from where stopped, or start from scratch after resetting the count. In both cases a delay is introduced.
                                                        </li>
                                                        <li>
                                                        An RTSJ <code>Timer</code>, when using the counter model, resets the count when it is re-started after being stopped.
                                                        </li>
                                                        </ul>
                        </li>
                                                <li>Timer modeled as comparator:  The timer is viewed as if every clock interrupt forces a comparison between an absolute time and a firing time, initially given either as an instance of AbsoluteTime or computed as the sum of an instance of <code>RelativeTime</code> and a semantically specified &quot;now&quot; (using the same clock).
                                                        <ul>
                                                        <li>
                                                        In this model, <code>start</code> is understood as start comparing, and possibly the first <code>start</code> is understood as defining &quot;now&quot;. <code>stop</code> is understood as stop comparing. <code>start</code> after <code>stop</code> may be understood as start comparing again. In this case no delay is introduced.
                                                        </li>
                                                        </ul>
                        </li>
                                        </ol>
                        
                        <li>When a <code>Timer</code> is created or rescheduled using a <code>RelativeTime</code> to specify the initial firing time, the RTSJ keeps the specified initial firing time as a <code>RelativeTime</code> and behaves according to the counter model.
                        </li>
                        <li>When a <code>Timer</code> is created or rescheduled using an <code>AbsoluteTime</code> to specify the initial firing time, the RTSJ keeps the specified initial firing time as an <code>AbsoluteTime</code> and uses the comparator model.
                        </li>
                </ol>
                        </li>
                        <li>The <code>Clock</code> class shall be capable of reporting the achievable resolution of timers based on that clock.
                        <li>The <code>OneShotTimer</code> class shall ensure that a one-shot timer is triggered at most once unless restarted after expiration.
                        <li>The <code>PeriodicTimer</code> class shall allow the period of the timer to be expressed in terms of a <code>RelativeTime</code> or a <code>RationalTime</code> (now deprecated).

<li>The initial firing, or skipping, of a <code>PeriodicTimer</code>
occurs in response to the invocation of its <code>start</code> method,
in accordance with the start time passed to its constructor.
This initial firing, or skipping, may be rescheduled by a call to the
<code>reschedule</code> method, in accordance with the time passed to that
method.

<li>For a <code>PeriodicTimer</code>:
  <ol type="a">
  <li>
  Let <em>S</em> be the absolute time at which the initial firing
  or skipping of a <code>PeriodicTimer</code> is scheduled to occur:
    <ol type="i">
    <li>
    If the start, or reschedule, time was given as an absolute
    time, <em>A</em>, and that time is in the future when the timer is made
    active, then <em>S</em> equals <em>A</em>. Otherwise, if the absolute time
    has passed when the timer is made active, then <em>S</em> equals
    the time at which the timer was made active.
    </li>
    <li>
    If the start, or reschedule, time was given as a relative
    time, <em>R</em>, then <em>S</em> equals the time at which the
    <i>counting time</i>, started when the timer was made <i>active</i>,
    equals <em>R</em>.
    <br>
    NOTE: The transition to <i>not-active</i> by this timer causes the
    <i>counting time</i> to reset, effectively preventing this kind of timer
    from firing immediately, unless given a time value of 0.
    </li>
    </ol>
  <li>
  The firings, or skippings, of a <code>PeriodicTimer</code> are scheduled
  to occur according to <em>S+nT</em>, for <em>n = 0, 1, 2 ...,</em>
  where <em>S</em> is as just specified, and <em>T</em> is the interval
  of the periodic timer.
  </li>
  </ol>
</li>

                        <li>When in a <i>not-active</i> state a <code>Timer</code> retains the parameters given at construction time or the parameters it had at de-activation time. Those are the parameters that will be used upon invocation of <code>start</code> while in that state, unless the parameters are explicitly changed before that, using <code>reschedule</code> and <code>setInterval</code> as appropriate. 
                        <li>If a <code>Timer</code> object is allocated in a scoped memory area, then it will increment the reference count associated with that area. Such a reference count will only be decremented when the <code>Timer</code> object is destroyed.  (See semantics in the <A HREF="mem_overview-summary.html"><em>Memory</em></A> chapter for details.)<li>A <code>Timer</code> object will not fire before
                        its due time.
                </ol>
                <h2>Rationale</h2>
                <p>Clocks differ because of monotonicity, synchronization, jitter, stability, accuracy, and resolution. There are many possible subclasses of clocks: real-time clocks, user time clocks, simulation time clocks, wall clocks.</p>
                <p>The idea of using multiple clocks may at first seem unusual but it is allowed to accommodate differences and as a possible resource allocation strategy. Consider a real-time system where the natural events of the system have different tolerances for jitter. Assume the system functions properly if event <em>A</em> is fired within plus or minus 100 seconds of the actual time it should occur but event <em>B</em> must be fired within 100 microseconds of its actual time. Further assume, without loss of generality, that events <em>A</em> and <em>B</em> are periodic. An application could then create two instances of <code>PeriodicTimer</code> based on two clocks. The timer for event <em>B</em> should be based on a <code>Clock</code> which checks its queue at least every 100 microseconds but the timer for event <em>A</em> could be based on a <code>Clock</code> that checked its queue only every 100 seconds. This use of two clocks reduces the queue size of the accurate clock and thus queue management overhead is reduced.</p>
                <p>The importance of the use of one-shot timers for time-out behavior and the vagaries in the execution of code prior to starting the timer for short time-outs dictate that the triggering of the timer should be guaranteed. The problem is exacerbated for periodic timers where the importance of the periodic triggering outweighs the precision of the start time. In such cases, it is also convenient to allow, for example, a relative time of zero to be used as the start time.</p>
<P>

<P>
<HR>

<HR>

</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_06) on Mon Jun 26 19:39:27 EDT 2006 -->
<TITLE>
Overview (Memory)
</TITLE>

<META NAME="keywords" CONTENT="Overview">

<LINK REL ="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Overview (Memory)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">

<HR>
Memory Management
                This section defines classes directly related to memory and memory management.
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#overview_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Packages</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="javax/realtime/package-summary.html">javax.realtime</A></B></TD>
<TD>&nbsp;</TD>
</TR>
</TABLE>

<P>
&nbsp;<A NAME="overview_description"><!-- --></A>
<P>
<h1>Memory Management</h1>
                <p>This section defines classes directly related to memory and memory management. These classes:</p>
                <ul>
                        <li>Allow the definition of regions of memory outside of the traditional Java heap.
                        <li>Allow the definition of regions of scoped memory, that is, memory regions with a limited lifetime.
                        <li>Allow the definition of regions of memory containing objects whose lifetime matches that of the application.
                        <li>Allow the definition of regions of memory mapped to specific physical addresses.
                        <li>Allow the specification of maximum memory area consumption and maximum allocation rates for individual schedulable objects.
                        <li>Allow the programmer to query information characterizing the behavior of the garbage collection algorithm, and to some limited ability, alter the behavior of that algorithm.
                </ul>
                <h2>Definitions</h2>
                <p>Schedulable objects that use the <code>enter</code> method of <code>MemoryArea</code> behave effectively as if they kept the memory areas they enter in a <em>scope stack </em>which <code>enter</code> pushes and pops.</p>
                <p>This chapter defines memory area classes. Two memory areas may be associated with each <code>MemoryArea</code> instance, the memory area containing the instance and the <em>backing memory</em> that contains memory managed by the <code>MemoryArea</code> instance.</p>
                <p>Some memory area classes implement <em>portals. </em>These are a tool that associates a reference value with a memory area. It is normally used to give code that has a reference to the memory area a way to go from that to a reference to an object stored in that memory area.</p>
                <p>For purposes of scoped memory reference counting, the following are treated as <a name="Anchor-execution-11481" id="Anchor-execution-11481"></a><em>execution contexts</em>:</p>

                                                <ul>
                                                        <li><code>RealtimeThread</code> objects that have been started and have not terminated,
                                                        <li><tt>AsyncEventHandler</tt> objects that are currently in a released state,
                                                        <li><tt>AsyncEvent</tt> objects that are bound to happenings,
                                                        <li><tt>Timer</tt> objects that have been started and have not been destroyed,
                                                        <li>other schedulable objects that control an execution engine
                                                </ul>
                                        
                <p>The initial memory area for a schedulable object is <a name="Anchor-non-default-14210" id="Anchor-non-default-14210"></a><em>non-default</em> if it is not the memory area where the schedulable object was created.</p>
                <p>An <code>AsyncEventHandler</code> is <a name="Anchor-fireable-23240" id="Anchor-fireable-23240"></a><em>fireable</em> whenever there is an agent that can release it.  This includes cases when the AsyncEventHandler is:</p>
                <ul>
                        <li>A miss handler, or overrun handler for a real-time thread that has been started but not yet terminated
                        <li>A miss handler or overrun handler for an AsyncEventHandler that is itself fireable;
                        <li>A handler associated with an AsyncEvent bound to a happening;
                        <li>A handler associated with a Timer that has been started but not yet destroyed;
                        <li>A handler associated with an AsyncEvent that can be programmatically fired
                </ul>
                <h2>Semantics and Requirements</h2>
                <p>The following list establishes the semantics and requirements that are applicable across the classes of this section. Semantics that apply to particular classes, constructors, methods, and fields will be found in the class description and the constructor, method, and field detail sections.</p>
                <h3>Allocation time</h3>
                <ol>
                        <li>Some <tt>MemoryArea</tt> classes are required to have linear (in object size) allocation time. The linear time attribute requires that, ignoring performance variations due to hardware caches or similar optimizations and ignoring execution time of any static initializers, the execution time of <tt>new</tt> must be bounded by a polynomial, <em>f(n)</em>, where <em>n</em> is the size of the object and for all <em>n&gt;0</em>, <em>f(n) &lt;= Cn </em>for some constant <em>C.</em>
                        <li>Execution time of object constructors, and time spent in class loading and static initialization are not governed by bounds on object allocation in this specification, but setting default initial values for fields in the instance (as specified in <em>The Java Virtual Machine Specification, </em>Second Edition, section 2.5.1, &quot;Each class variable, instance variable, and array component is initialized with a default value when it is created.&quot;) is considered part of object allocation and included in the time bound.
                                <h3>The allocation context</h3>
                        <li>A memory area is represented by an instance of a subclass of the <code>MemoryArea</code> class. When a memory area, <var>m</var>, is entered by calling <code>m.enter </code>(or another method from the family of enter-like methods in <code>MemoryArea</code> or <code>ScopedMemory</code>) <var>m</var> becomes the <em>allocation context</em> of the current schedulable object. When control returns from the <tt>enter</tt> method, the allocation context is restored to the value it had immediately before <tt>enter</tt> was called.
                        <li>When a memory area, <em>m</em>, is entered by calling <em>m</em>'s <tt>executeInArea</tt> method, <em>m </em>becomes the current allocation context of the current schedulable object. When control returns from the <tt>executeInArea</tt> method, the allocation context is restored to the value it had before <tt>executeInArea</tt> was called.
                        <li>The initial allocation context for a schedulable object when it is first released, is the memory area that was designated the<em> initial memory area</em> when the schedulable object was constructed. This initial allocation context becomes the current allocation context for that schedulable object when the schedulable object first becomes eligible for execution. For async event handlers, the initial allocation context is the same on each release; for real-time threads, in releases subsequent to the first, the allocation context is the same as it was when the real-time thread became <em>blocked-for-release-event.</em>
                        <li>All object allocation through the <tt>new</tt> keyword will use the current allocation context, but note that allocation can be performed in a specific memory area using the <code>newInstance</code> and <code>newArray</code> methods.
                        <li>Schedulable objects behave as if they stored their memory area context in a structure called the <i>scope stack</i>. This structure is manipulated by creation of schedulable objects, and the following methods from the <code>MemoryArea</code> and <code>ScopedMemory</code> classes: all the <code>enter</code> and <code>joinAndEnter</code> methods, <code>executeInArea</code>, and both <code>newInstance</code> methods. See the semantics in Maintaining the Scope Stack for details.
                        <li>The scope stack is accessible through a set of static methods on <tt>RealtimeThread</tt>. These methods allow outer allocation contexts to be accessed by their index number. Memory areas on a scope stack may be referred to as <em>inner</em> or <em>outer</em> relative to other entries in that scope stack. An &quot;outer scope&quot; is further from the current allocation context on the current scope stack and has a lower index.
                        <li>The <code>executeInArea, newInstance</code> and <code>newArray</code> methods, when invoked on an instance of&nbsp; <code>ScopedMemory</code> require that instance to be an outer allocation context on the current schedulable object's current scope stack.
                        <li>An instance of <code>ScopedMemory</code> is said to be <em>in use</em> if it has a non-zero reference count as defined by semantic (17) below.</li>
                                <h3>The Parent Scope</h3>
                        <li>Instances of <tt>ScopedMemory</tt> have special semantics including definition of <em>parent.</em> If a <tt>ScopedMemory</tt> object is neither in use nor the initial memory area for a schedulable object, it has no <em>parent</em> scope. 
                        <ul>
                                <li>When a <code>ScopedMemory</code> object becomes in use, its parent is the nearest <code>ScopedMemory</code> object outside it on the current scope stack. If there is no outside <code>ScopedMemory</code> object in the current scope stack, the parent is the <em>primordial</em> <em>scope </em>which is not actually a memory area, but only a marker that constrains the parentage of <code>ScopedMemory</code> objects.
                                <li>At construction of a schedulable object, if the initial memory area has no parent, the initial memory area is assigned the parent it will have when the schedulable object is in execution.  This rule determines the initial memory area's parent until the schedulable object is de-allocated from its memory area, or, if the schedulable object is a <code>RealtimeThread</code>, it completes execution
                        </ul>
                        <li>Instances of <tt>ScopedMemory</tt> must satisfy the <em>single parent rule</em><i> </i>which requires that each scoped memory has a unique parent as defined in semantic (11.)<font color="#00FF00"> </font>
                        <h3>Memory areas and schedulable objects</h3>
                        <li>Pushing a scoped memory onto a scope stack is always subject to the single parent rule.
                        <li>Each schedulable object has an initial memory area which is that object's initial allocation context. The default initial memory area is the current allocation context in effect during execution of the schedulable object's constructor, but schedulable objects may supply constructors that override the default.
                        <li>A Java thread cannot have a scope stack; consequently it can only be created and execute within heap or immortal memory. An attempt to create a Java thread in a scoped memory area throws <code>IllegalAssignmentError</code>.
                        <li>A Java thread may use <code>executeInArea</code>, and the <code>newInstance</code> and <code>newArray</code> methods from the <code>ImmortalMemory </code>and<code> HeapMemory </code>classes. These methods allow it to execute with an immortal current allocation context, but semantic (15) applies even during execution of these methods.
                        <h3>Scoped memory reference counting</h3>
                        <li>Each instance of the class <code>ScopedMemory</code> or its subclasses must maintain a reference count which is greater than zero if and only if either:
                                <ul>
                                        <li>the scoped memory area is the current allocation context or an outer allocation context for one or more <em><a href="#Anchor-execution-11481">execution contexts</a></em>; or else
                                        <li>the scoped memory area is the <em><a href="#Anchor-non-default-14210">non-default initial memory area</a></em> for a <em><a href="#Anchor-fireable-23240">fireable</a></em>  <code>AsyncEventHandler</code>.
                                </ul></li>
                        <li>When the reference count for an instance of the class <tt>ScopedMemory</tt> is ready to be decremented from one to zero, all unfinalized objects within that area are considered ready for finalization. If after the finalizers for all such unfinalized objects in the scoped memory area run to completion, the reference count for the memory area is still ready to be decremented to zero, any newly created unfinalized objects are considered ready for finalization and the process is repeated until no new objects are created or the scoped memory's reference count is no longer ready to be decremented from one to zero. When the scope contains no unfinalized objects and its reference count is ready to be decremented from one to zero, then the reference count is decremented to zero and the memory scope is emptied of all objects. The RTSJ implementation must complete finalization of objects in the scope and, if the reference count is zero after finalizers run, deletion of the objects in the scope before that memory scope can again become the current allocation context for any schedulable object. (This is a special case of the finalization implementation specified in <em>The Java Language Specification</em>, second edition, section 12.6.1)
                        <li>Finalization may start when all unfinalized objects in the scope are ready for finalization. Finalizers are executed with the current allocation context set to the finalizing scope and are executed by the schedulable object in control of the scope when its reference count is ready to be decremented from one to zero. If finalizers are executed because a real-time thread terminates or an <code>AsyncEventHandler</code> becomes non-fireable, that real-time thread or <code>AsyncEventHandler</code> is considered in control of the scope and must execute the finalizers.<li>From the time objects in a scope are deleted until the portal on the scope is successfully set to a non-null value with <tt>setPortal,</tt> the value returned by <tt>getPortal</tt> on that scoped memory object must be <tt>null</tt>.
                        <h3>Immortal memory</h3>
                        <li>Objects created in any immortal memory area are unexceptionally referenceable from all Java threads, and all schedulable objects, and the allocation and use of objects in immortal memory is never subject to garbage collection delays.
                        <li>An implementation may execute finalizers for immortal objects when it determines that the application has terminated. Finalizers will be executed by a thread or schedulable object whose current allocation context is not scoped memory. Regardless of any call to <code>runFinalizersOnExit</code>, the system need not execute finalizers for immortal objects that remain unfinalized when the JVM begins termination.
                        <li>Class objects, the associated static memory, and interned Strings behave effectively as if they were allocated in immortal memory with respect to reference rules, assignment rules, and preemption delays by no-heap schedulable objects. Static initializers are executed effectively as if the current thread performed <code>ImmortalMemory.instance().executeInArea(r)</code> where <code>r</code> is a <code>Runnable</code> that executes the <code>&lt;clinit&gt;</code> method of the class being initialized.
                        <h3>Maintaining referential integrity</h3>
                        <li>Assignment rules placed on reference assignments prevent the creation of dangling references, and thus maintain the referential integrity of the Java runtime. The restrictions are listed in the following table:
                                <table border>
                                        <tr>
                                                <th align="center" valign="CENTER" width="55">
                                                        <div align="center">
                                                                <strong><font size="-2">Stored In</font></strong></div>
                                                </th>
                                                <th align="center" valign="CENTER" width="64">
                                                        <div align="center">
                                                                <b><font size="-2">Reference<br>
                                                                                to<br>
                                                                                Heap</font></b></div>
                                                </th>
                                                <th align="center" valign="CENTER" width="64">
                                                        <div align="center">
                                                                <b><font size="-2">Reference<br>
                                                                                to<br>
                                                                                Immortal</font></b></div>
                                                </th>
                                                <th align="center" valign="CENTER" width="138">
                                                        <div align="center">
                                                                <b><font size="-2">Reference to Scoped</font></b></div>
                                                </th>
                                                <th align="center" valign="CENTER" width="40">
                                                        <div align="center">
                                                                <b><font size="-2">null</font></b></div>
                                                </th>
                                        </tr>
                                        <tr>
                                                <td valign="CENTER" width="55">
                                                        <center>
                                                                <b><font size="-2">Heap</font></b></center>
                                                </td>
                                                <td valign="CENTER" width="64">
                                                        <center>
                                                                <font size="-2">Permit</font></center>
                                                </td>
                                                <td valign="CENTER" width="64">
                                                        <center>
                                                                <font size="-2">Permit</font></center>
                                                </td>
                                                <td align="left" valign="CENTER" width="138">
                                                        <center>
                                                                <font size="-2">Forbid</font></center>
                                                </td>
                                                <td valign="CENTER" width="40"><font size="-2">Permit</font></td>
                                        </tr>
                                        <tr>
                                                <td valign="CENTER" width="55">
                                                        <center>
                                                                <b><font size="-2">Immortal</font></b></center>
                                                </td>
                                                <td valign="CENTER" width="64">
                                                        <center>
                                                                <font size="-2">Permit</font></center>
                                                </td>
                                                <td valign="CENTER" width="64">
                                                        <center>
                                                                <font size="-2">Permit</font></center>
                                                </td>
                                                <td align="left" valign="CENTER" width="138">
                                                        <center>
                                                                <font size="-2">Forbid</font></center>
                                                </td>
                                                <td valign="CENTER" width="40"><font size="-2">Permit</font></td>
                                        </tr>
                                        <tr>
                                                <td valign="CENTER" width="55">
                                                        <center>
                                                                <b><font size="-2">Scoped</font></b></center>
                                                </td>
                                                <td valign="CENTER" width="64">
                                                        <center>
                                                                <font size="-2">Permit</font></center>
                                                </td>
                                                <td valign="CENTER" width="64">
                                                        <div align="center">
                                                                <font size="-2">Permit</font></div>
                                                </td>
                                                <td align="left" valign="CENTER" width="138">
                                                        <div align="left">
                                                                <font size="-2">Permit, if the reference is from the same scope, or an outer scope</font></div>
                                                </td>
                                                <td valign="CENTER" width="40"><font size="-2">Permit</font></td>
                                        </tr>
                                        <tr>
                                                <td valign="CENTER" width="55">
                                                        <center>
                                                                <b><font size="-2">Local Variable</font></b></center>
                                                </td>
                                                <td valign="CENTER" width="64">
                                                        <center>
                                                                <font size="-2">Permit</font></center>
                                                </td>
                                                <td valign="CENTER" width="64">
                                                        <center>
                                                                <font size="-2">Permit</font></center>
                                                </td>
                                                <td align="left" valign="CENTER" width="138">
                                                        <center>
                                                                <font size="-2">Permit</font></center>
                                                </td>
                                                <td valign="CENTER" width="40"><font size="-2">Permit</font></td>
                                        </tr>
                                </table>
                                <p>For this table, <code>ImmortalMemory</code> and <code>ImmortalPhysicalMemory</code> are equivalent, and all sub-classes of <code>ScopedMemory</code> are equivalent.</p>
                        <li>An implementation must ensure that the above checks are performed on every assignment statement before the statement is executed. (This includes the possibility of static analysis of the application logic). Checks for operations on local variables are not required because a potentially invalid reference would be captured by the other checks before it reached a local variable.
                        <h3>Object initialization</h3>
                        <li>Static initializers run with the immortal memory area as their allocation context.
                        <li>The current allocation context in a constructor for an object is the memory area in which the object is allocated. For <tt>new</tt>, this is the current allocation context when <tt>new</tt> was called. For members of the <tt>m.newinstance</tt> family, the current allocation context is memory area <i>m.</i>
                </ol>
                <h2>Maintaining the Scope Stack</h2>
                
                        This section describes maintenance of a data structure that is called the <i>scope stack</i>. Implementations are not required to use a stack or implement the algorithms given here. It is only required that an implementation behave with respect to the ordering and accessibility of memory scopes effectively as if it implemented these algorithms.
                <p>The scope stack is implicitly visible through the assignment rules, and the stack is explicitly visible through the <tt>static getOuterMemoryArea(int index)</tt> method on <tt>RealtimeThread</tt>.</p>
                <p>Four operations effect the scope stack: the <tt>enter</tt> methods in <code>MemoryArea</code> and <tt>ScopedMemory</tt>, construction of a new schedulable object, the <tt>executeInArea</tt> method in <tt>MemoryArea,</tt> and the new instance methods in <tt>MemoryArea.</tt></p>
                <ol>
                        <li value="28">The memory area at the top of a schedulable object's scope stack is the schedulable object's current allocation context.
                        <li>When a schedulable object,<em> t</em>, creates a schedulable object, <em>n<sub>t</sub></em>, in a <tt>ScopedMemory</tt> object's allocation area, <em>n<sub>t</sub></em> acquires a copy of the scope stack associated with <em>t</em> at the time <em>n<sub>t</sub></em> is constructed including all entries from up to and including the memory area containing <em>n<sub>t</sub></em>. If <em>n<sub>t</sub></em> is created in heap, immortal, or immortal physical memory, <em>n<sub>t</sub></em> is created with a scope stack containing only heap, immortal, or immortal physical memory respectively. If <em>n<sub>t</sub></em> has a non-default initial memory area, <em>ima</em>, then <em>ima</em> is pushed on <em>n<sub>t</sub></em>'s newly-created scope stack.<li>When a memory area, <code>ma,</code>&nbsp;is entered by calling a <code>ma.enter</code> method, <code>ma</code> is pushed on the scope stack and becomes the <i>allocation context</i> of the &nbsp;current schedulable object. When control returns from the <code>enter</code> &nbsp;method, the allocation context is popped from the scope stack
                        <li>When a memory area, <code>m</code>, is entered by calling <code>m</code>'s <code>executeInArea</code> method or one of the <code>m.newInstance</code> methods the scope stack before the method call is preserved and replaced with a scope stack constructed as follows:
                                <ul>
                                        <li>If <code>ma</code> is a scoped memory area the new scope stack is a copy of the schedulable object's previous scope stack up to and including <code>ma</code>.
                                        <li>If <code>ma</code> is not a scoped memory area the new scope stack includes only <code>ma</code>.
                                </ul>
                                When control returns from the <code>executeInArea</code> method, the scope stack is restored to the value it had before <code>ma.executeInArea</code> or <code>ma.newInstance</code> was called.
                </ol>
                <p>Notes:</p>
                <ul>
                        <li>For the purposes of these algorithms, stacks grow <i>up.</i>
                        <li>The representative algorithms ignore important issues like freeing objects in scopes.
                        <li>In every case, objects in a scoped memory area are eligible to be freed when the reference count for the area is zero after finalizers for that scope are run.
                        <li>Informally, any objects in a scoped memory area <i>must</i> be freed and their finalizers run before the reference count for the memory area is incremented from zero to one.
                </ul>
                <h4>enter</h4>
                <pre>For<code> ma.enter(logic):
</code><code>push ma on the scope stack belonging to the current
    schedulable object -- which may throw
      ScopedCycleException
execute logic.run method
pop ma from the scope stack</code></pre>
                <h4>executeInArea or newInstance</h4>
                For <tt>ma.executeInArea(logic),</tt> <tt>ma.newInstance(),</tt> or <tt>ma.newArray()</tt>:
                <pre><tt>if ma is an instance of heap immortal or 
        ImmortalPhysicalMemory
&nbsp;&nbsp;&nbsp; start a new scope stack containing only ma
&nbsp;&nbsp;&nbsp; make the new scope stack the scope stack for
        the current schedulable object
else ma is scoped
&nbsp;&nbsp;&nbsp; if ma is in the scope stack for the 
            current schedulable object
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start a new scope stack containing ma and all
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scopes below ma on the scope stack.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; make the new scope stack the scope stack for 
            the current schedulable object
&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw InaccessibleAreaException
execute logic.run or construct the object
restore the previous scope stack for the 
        current schedulable object
discard the new scope stack</tt></pre>
                <h4>Construct a Schedulable Object</h4>
                For construction of a schedulable object in memory area <code>cma</code> with initial memory area of <code>ima</code>:
                <pre><tt>if cma is heap, immortal or ImmortalPhysicalMemory
&nbsp;&nbsp;&nbsp; create a new scope stack containing cma
else
&nbsp;&nbsp;&nbsp; start a new scope stack containing the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; entire current scope stack
                                
                                
if ima != cma
&nbsp;&nbsp;&nbsp; push ima on the new scope stack --
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; which may throw ScopedCycleException</tt></pre>
                <p>The above pseudocode illustrates a straightforward implementation of this specification's semantics, but any implementation that behaves effectively like this one with respect to reference count values of zero and one is permissible. An implementation may be eager or lazy in maintenance of its reference count provided that it correctly implements the semantics for reference counts of zero and one.</p>
                <h2>The Single Parent Rule</h2>
                Every push of a scoped memory type on a scope stack requires reference to the single parent rule, this enforces the invariant that every scoped memory area has no more than one parent.
                <p>The parent of a scoped memory area is identified by the following rules (for a stack that grows up):</p>
                <ul>
                        <li>If the memory area is not currently on any scope stack, it has no parent
                        <li>If the memory area is the outermost (lowest) scoped memory area on any scope stack, its parent is the <i>primordial scope.</i>
                        <li>For all other scoped memory areas, the parent is the first scoped memory area outside it on the scope stack.
                </ul>
                Except for the primordial scope, which represents heap, immortal and immortal physical memory, only scoped memory areas are visible to the single parent rule.
                
                <p>The operational effect of the single parent rule is that when a scoped memory area has a parent, the only legal change to that value is to &quot;no parent.&quot; Thus an ordering imposed by the first assignments of parents of a series of nested scoped memory areas is the only nesting order allowed until control leaves the scopes; then a new nesting order is possible. Thus a schedulable object attempting to enter a scope can only do so by entering in the established nesting order.</p>
                <h3>Scope Tree Maintenance</h3>
                The single parent rule is enforced effectively as if there were a tree with the primordial scope (representing heap, immortal, and immortal physical memory) at its root, and other nodes corresponding to every scoped memory area that is currently on any schedulable object's scope stack.
                <p>Each scoped memory has a reference to its parent memory area, <tt>ma.parent</tt>. The parent reference may indicate a specific scoped memory area, no parent, or the primordial parent.</p>
                <p>If a scoped memory area is the non-default initial memory area of an async event handler, or the non-default initial memory area of a real-time thread that has not terminated, it is referred to as <em>pinned</em>.</p>
                <h5>On Scope Stack Push of ma</h5>
                The following procedure could be used to maintain the scope tree and ensure that push operations on a schedulable object's scope stack do not violate the single parent rule.
                <pre><tt>precondition: ma.parent is set to the correct parent 
    (either a scoped memory area or the primordial scope) 
    or to noParent      
                                
                                
t.scopeStack is the scope stack of 
    the current schedulable object

if ma is scoped
&nbsp;  parent = findFirstScope(t.scopeStack)
&nbsp;&nbsp; if ma.parent == noParent
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ma.parent = parent
&nbsp;&nbsp; else if ma.parent != parent
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw ScopedCycleException
&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t.scopeStack.push(ma)</tt></pre>
                <tt>findFirstScope</tt> is a convenience function that looks down the scope stack for the next entry that is a reference to an instance of <tt>ScopedMemoryArea</tt>.
                <pre><tt>findFirstScope(scopeStack) {
&nbsp;&nbsp; for s = top of scope stack to 
         bottom of scope stack
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if s is an instance of scopedMemory
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return s
&nbsp;&nbsp; return primordial scope                            
}</tt></pre>
                <h5>On Scope Stack Pop of ma</h5>
                <pre><tt>ma = t.scopeStack.pop()
if ma is scoped
&nbsp;&nbsp;&nbsp; if !(ma.in_use || ma.pinned)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ma.parent = noParent</tt></pre>
                <h2>The Rationale</h2>
                <p>Languages that employ automatic reclamation of blocks of memory allocated in what is traditionally called the heap by program logic also typically use an algorithm called a garbage collector. Garbage collection algorithms and implementations vary in the amount of non-determinacy they add to the execution of program logic. Rather than require a garbage collector, and require it to meet real-time constraints that would necessarily be a compromise, this specification constructs alternative systems for &quot;safe&quot; management of memory. The scoped and immortal memory areas allow program logic to allocate objects in a Java-like style, ignore the reclamation of those objects, and not incur the latency of the implemented garbage collection algorithm.</p>
                <p>The term <em>scope stack</em> might mislead a reader to infer that it contains only scoped memory areas. This is incorrect. Although the scope stack may contain scoped memory references, it may also contain heap and immortal memory areas. Also, although the scope stack's behavior is specified as a stack, an implementation is free to use any data structure that preserves the stack semantics.</p>
                <p>This specification does not specifically address the lifetime of objects allocated in immortal memory areas. If they were reclaimed while they were still referenced, the referential integrity of the JVM would be compromised which is not permissible. Recovering immortal objects only at the termination of the application, or never recovering them under any circumstances is consistent with this specification.</p>
                <p>If a scoped memory area is used by both heap and non-heap SOs, there could be cases where a finalizer executed in non-heap context could attempt to use a heap reference left by a heap-using SO. The code in the finalizer would throw a memory access error. If that exception is not caught in the finalizer, it will be handled by the implementation so finalization will continue undisturbed, but the problem in finalizer that caused the illegal memory access could be hard to locate. So, catch clauses in finalizers for objects allocated in scoped memory are even more useful than they are for normal finalizers.</p>
<P>

<P>
<HR>

<HR>

</BODY>
</HTML>
